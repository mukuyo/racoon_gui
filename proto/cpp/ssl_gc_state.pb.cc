// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssl_gc_state.proto

#include "ssl_gc_state.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR YellowCard::YellowCard(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.caused_by_game_event_)*/nullptr
  , /*decltype(_impl_.time_remaining_)*/nullptr
  , /*decltype(_impl_.id_)*/0u} {}
struct YellowCardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR YellowCardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~YellowCardDefaultTypeInternal() {}
  union {
    YellowCard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 YellowCardDefaultTypeInternal _YellowCard_default_instance_;
PROTOBUF_CONSTEXPR RedCard::RedCard(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.caused_by_game_event_)*/nullptr
  , /*decltype(_impl_.id_)*/0u} {}
struct RedCardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RedCardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RedCardDefaultTypeInternal() {}
  union {
    RedCard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RedCardDefaultTypeInternal _RedCard_default_instance_;
PROTOBUF_CONSTEXPR Foul::Foul(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.caused_by_game_event_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.id_)*/0u} {}
struct FoulDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FoulDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FoulDefaultTypeInternal() {}
  union {
    Foul _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FoulDefaultTypeInternal _Foul_default_instance_;
PROTOBUF_CONSTEXPR Command::Command(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.for_team_)*/0} {}
struct CommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandDefaultTypeInternal() {}
  union {
    Command _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandDefaultTypeInternal _Command_default_instance_;
PROTOBUF_CONSTEXPR GameState::GameState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.for_team_)*/0} {}
struct GameStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameStateDefaultTypeInternal() {}
  union {
    GameState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameStateDefaultTypeInternal _GameState_default_instance_;
PROTOBUF_CONSTEXPR Proposal::Proposal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.game_event_)*/nullptr} {}
struct ProposalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProposalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProposalDefaultTypeInternal() {}
  union {
    Proposal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProposalDefaultTypeInternal _Proposal_default_instance_;
PROTOBUF_CONSTEXPR ProposalGroup::ProposalGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.proposals_)*/{}
  , /*decltype(_impl_.accepted_)*/false} {}
struct ProposalGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProposalGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProposalGroupDefaultTypeInternal() {}
  union {
    ProposalGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProposalGroupDefaultTypeInternal _ProposalGroup_default_instance_;
PROTOBUF_CONSTEXPR TeamInfo::TeamInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.yellow_cards_)*/{}
  , /*decltype(_impl_.red_cards_)*/{}
  , /*decltype(_impl_.fouls_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timeout_time_left_)*/nullptr
  , /*decltype(_impl_.requests_bot_substitution_since_)*/nullptr
  , /*decltype(_impl_.requests_timeout_since_)*/nullptr
  , /*decltype(_impl_.requests_emergency_stop_since_)*/nullptr
  , /*decltype(_impl_.goals_)*/0
  , /*decltype(_impl_.goalkeeper_)*/0
  , /*decltype(_impl_.timeouts_left_)*/0
  , /*decltype(_impl_.ball_placement_failures_)*/0
  , /*decltype(_impl_.on_positive_half_)*/false
  , /*decltype(_impl_.ball_placement_failures_reached_)*/false
  , /*decltype(_impl_.can_place_ball_)*/false
  , /*decltype(_impl_.max_allowed_bots_)*/0
  , /*decltype(_impl_.challenge_flags_)*/0} {}
struct TeamInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TeamInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TeamInfoDefaultTypeInternal() {}
  union {
    TeamInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TeamInfoDefaultTypeInternal _TeamInfo_default_instance_;
PROTOBUF_CONSTEXPR State_TeamStateEntry_DoNotUse::State_TeamStateEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct State_TeamStateEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR State_TeamStateEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~State_TeamStateEntry_DoNotUseDefaultTypeInternal() {}
  union {
    State_TeamStateEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 State_TeamStateEntry_DoNotUseDefaultTypeInternal _State_TeamStateEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR State::State(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_state_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.game_events_)*/{}
  , /*decltype(_impl_.proposal_groups_)*/{}
  , /*decltype(_impl_.command_)*/nullptr
  , /*decltype(_impl_.stage_time_elapsed_)*/nullptr
  , /*decltype(_impl_.stage_time_left_)*/nullptr
  , /*decltype(_impl_.match_time_start_)*/nullptr
  , /*decltype(_impl_.placement_pos_)*/nullptr
  , /*decltype(_impl_.next_command_)*/nullptr
  , /*decltype(_impl_.current_action_time_remaining_)*/nullptr
  , /*decltype(_impl_.game_state_)*/nullptr
  , /*decltype(_impl_.stage_)*/0
  , /*decltype(_impl_.division_)*/0
  , /*decltype(_impl_.auto_continue_)*/false
  , /*decltype(_impl_.first_kickoff_team_)*/0
  , /*decltype(_impl_.match_type_)*/0} {}
struct StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateDefaultTypeInternal() {}
  union {
    State _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateDefaultTypeInternal _State_default_instance_;
static ::_pb::Metadata file_level_metadata_ssl_5fgc_5fstate_2eproto[10];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_ssl_5fgc_5fstate_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ssl_5fgc_5fstate_2eproto = nullptr;

const uint32_t TableStruct_ssl_5fgc_5fstate_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::YellowCard, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::YellowCard, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::YellowCard, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::YellowCard, _impl_.caused_by_game_event_),
  PROTOBUF_FIELD_OFFSET(::YellowCard, _impl_.time_remaining_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::RedCard, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::RedCard, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RedCard, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::RedCard, _impl_.caused_by_game_event_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::Foul, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Foul, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Foul, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Foul, _impl_.caused_by_game_event_),
  PROTOBUF_FIELD_OFFSET(::Foul, _impl_.timestamp_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Command, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Command, _impl_.for_team_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::GameState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::GameState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::GameState, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::GameState, _impl_.for_team_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Proposal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Proposal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proposal, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::Proposal, _impl_.game_event_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ProposalGroup, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProposalGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProposalGroup, _impl_.proposals_),
  PROTOBUF_FIELD_OFFSET(::ProposalGroup, _impl_.accepted_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.goals_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.goalkeeper_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.yellow_cards_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.red_cards_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.timeouts_left_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.timeout_time_left_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.on_positive_half_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.fouls_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.ball_placement_failures_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.ball_placement_failures_reached_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.can_place_ball_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.max_allowed_bots_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.requests_bot_substitution_since_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.requests_timeout_since_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.requests_emergency_stop_since_),
  PROTOBUF_FIELD_OFFSET(::TeamInfo, _impl_.challenge_flags_),
  0,
  5,
  6,
  ~0u,
  ~0u,
  7,
  1,
  9,
  ~0u,
  8,
  10,
  11,
  12,
  2,
  3,
  4,
  13,
  PROTOBUF_FIELD_OFFSET(::State_TeamStateEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::State_TeamStateEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::State_TeamStateEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::State_TeamStateEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::State, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::State, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::State, _impl_.stage_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.command_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.game_state_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.stage_time_elapsed_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.stage_time_left_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.match_time_start_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.team_state_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.placement_pos_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.next_command_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.current_action_time_remaining_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.game_events_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.proposal_groups_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.division_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.auto_continue_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.first_kickoff_team_),
  PROTOBUF_FIELD_OFFSET(::State, _impl_.match_type_),
  8,
  0,
  7,
  1,
  2,
  3,
  ~0u,
  4,
  5,
  6,
  ~0u,
  ~0u,
  9,
  10,
  11,
  12,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::YellowCard)},
  { 12, 20, -1, sizeof(::RedCard)},
  { 22, 31, -1, sizeof(::Foul)},
  { 34, 42, -1, sizeof(::Command)},
  { 44, 52, -1, sizeof(::GameState)},
  { 54, 62, -1, sizeof(::Proposal)},
  { 64, 72, -1, sizeof(::ProposalGroup)},
  { 74, 97, -1, sizeof(::TeamInfo)},
  { 114, 122, -1, sizeof(::State_TeamStateEntry_DoNotUse)},
  { 124, 146, -1, sizeof(::State)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_YellowCard_default_instance_._instance,
  &::_RedCard_default_instance_._instance,
  &::_Foul_default_instance_._instance,
  &::_Command_default_instance_._instance,
  &::_GameState_default_instance_._instance,
  &::_Proposal_default_instance_._instance,
  &::_ProposalGroup_default_instance_._instance,
  &::_TeamInfo_default_instance_._instance,
  &::_State_TeamStateEntry_DoNotUse_default_instance_._instance,
  &::_State_default_instance_._instance,
};

const char descriptor_table_protodef_ssl_5fgc_5fstate_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022ssl_gc_state.proto\032\023ssl_gc_common.prot"
  "o\032\025ssl_gc_geometry.proto\032\027ssl_gc_game_ev"
  "ent.proto\032\034ssl_gc_referee_message.proto\032"
  "\036google/protobuf/duration.proto\032\037google/"
  "protobuf/timestamp.proto\"u\n\nYellowCard\022\n"
  "\n\002id\030\001 \001(\r\022(\n\024caused_by_game_event\030\002 \001(\013"
  "2\n.GameEvent\0221\n\016time_remaining\030\003 \001(\0132\031.g"
  "oogle.protobuf.Duration\"\?\n\007RedCard\022\n\n\002id"
  "\030\001 \001(\r\022(\n\024caused_by_game_event\030\002 \001(\0132\n.G"
  "ameEvent\"k\n\004Foul\022\n\n\002id\030\001 \001(\r\022(\n\024caused_b"
  "y_game_event\030\002 \001(\0132\n.GameEvent\022-\n\ttimest"
  "amp\030\003 \001(\0132\032.google.protobuf.Timestamp\"\341\001"
  "\n\007Command\022\033\n\004type\030\001 \002(\0162\r.Command.Type\022\027"
  "\n\010for_team\030\002 \001(\0162\005.Team\"\237\001\n\004Type\022\013\n\007UNKN"
  "OWN\020\000\022\010\n\004HALT\020\001\022\010\n\004STOP\020\002\022\020\n\014NORMAL_STAR"
  "T\020\003\022\017\n\013FORCE_START\020\004\022\n\n\006DIRECT\020\005\022\014\n\010INDI"
  "RECT\020\006\022\013\n\007KICKOFF\020\007\022\013\n\007PENALTY\020\010\022\013\n\007TIME"
  "OUT\020\t\022\022\n\016BALL_PLACEMENT\020\n\"\303\001\n\tGameState\022"
  "\035\n\004type\030\001 \002(\0162\017.GameState.Type\022\027\n\010for_te"
  "am\030\002 \001(\0162\005.Team\"~\n\004Type\022\013\n\007UNKNOWN\020\000\022\010\n\004"
  "HALT\020\001\022\010\n\004STOP\020\002\022\013\n\007RUNNING\020\003\022\r\n\tFREE_KI"
  "CK\020\004\022\013\n\007KICKOFF\020\005\022\013\n\007PENALTY\020\006\022\013\n\007TIMEOU"
  "T\020\007\022\022\n\016BALL_PLACEMENT\020\010\"Y\n\010Proposal\022-\n\tt"
  "imestamp\030\001 \001(\0132\032.google.protobuf.Timesta"
  "mp\022\036\n\ngame_event\030\002 \001(\0132\n.GameEvent\"\?\n\rPr"
  "oposalGroup\022\034\n\tproposals\030\001 \003(\0132\t.Proposa"
  "l\022\020\n\010accepted\030\002 \001(\010\"\321\004\n\010TeamInfo\022\014\n\004name"
  "\030\001 \001(\t\022\r\n\005goals\030\002 \001(\005\022\022\n\ngoalkeeper\030\003 \001("
  "\005\022!\n\014yellow_cards\030\004 \003(\0132\013.YellowCard\022\033\n\t"
  "red_cards\030\005 \003(\0132\010.RedCard\022\025\n\rtimeouts_le"
  "ft\030\006 \001(\005\0224\n\021timeout_time_left\030\007 \001(\0132\031.go"
  "ogle.protobuf.Duration\022\030\n\020on_positive_ha"
  "lf\030\010 \001(\010\022\024\n\005fouls\030\t \003(\0132\005.Foul\022\037\n\027ball_p"
  "lacement_failures\030\n \001(\005\022\'\n\037ball_placemen"
  "t_failures_reached\030\013 \001(\010\022\026\n\016can_place_ba"
  "ll\030\014 \001(\010\022\030\n\020max_allowed_bots\030\r \001(\005\022C\n\037re"
  "quests_bot_substitution_since\030\016 \001(\0132\032.go"
  "ogle.protobuf.Timestamp\022:\n\026requests_time"
  "out_since\030\017 \001(\0132\032.google.protobuf.Timest"
  "amp\022A\n\035requests_emergency_stop_since\030\020 \001"
  "(\0132\032.google.protobuf.Timestamp\022\027\n\017challe"
  "nge_flags\030\021 \001(\005\"\256\005\n\005State\022\035\n\005stage\030\001 \001(\016"
  "2\016.Referee.Stage\022\031\n\007command\030\002 \001(\0132\010.Comm"
  "and\022\036\n\ngame_state\030\023 \001(\0132\n.GameState\0225\n\022s"
  "tage_time_elapsed\030\004 \001(\0132\031.google.protobu"
  "f.Duration\0222\n\017stage_time_left\030\005 \001(\0132\031.go"
  "ogle.protobuf.Duration\0224\n\020match_time_sta"
  "rt\030\006 \001(\0132\032.google.protobuf.Timestamp\022)\n\n"
  "team_state\030\010 \003(\0132\025.State.TeamStateEntry\022"
  "\037\n\rplacement_pos\030\t \001(\0132\010.Vector2\022\036\n\014next"
  "_command\030\n \001(\0132\010.Command\022@\n\035current_acti"
  "on_time_remaining\030\014 \001(\0132\031.google.protobu"
  "f.Duration\022\037\n\013game_events\030\r \003(\0132\n.GameEv"
  "ent\022\'\n\017proposal_groups\030\016 \003(\0132\016.ProposalG"
  "roup\022\033\n\010division\030\017 \001(\0162\t.Division\022\025\n\raut"
  "o_continue\030\020 \001(\010\022!\n\022first_kickoff_team\030\021"
  " \001(\0162\005.Team\022\036\n\nmatch_type\030\022 \001(\0162\n.MatchT"
  "ype\032;\n\016TeamStateEntry\022\013\n\003key\030\001 \001(\t\022\030\n\005va"
  "lue\030\002 \001(\0132\t.TeamInfo:\0028\001B-Z+github.com/R"
  "ione-SSL/RACOON-Pi/proto/pb_gen"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_ssl_5fgc_5fstate_2eproto_deps[6] = {
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
  &::descriptor_table_ssl_5fgc_5fcommon_2eproto,
  &::descriptor_table_ssl_5fgc_5fgame_5fevent_2eproto,
  &::descriptor_table_ssl_5fgc_5fgeometry_2eproto,
  &::descriptor_table_ssl_5fgc_5freferee_5fmessage_2eproto,
};
static ::_pbi::once_flag descriptor_table_ssl_5fgc_5fstate_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ssl_5fgc_5fstate_2eproto = {
    false, false, 2391, descriptor_table_protodef_ssl_5fgc_5fstate_2eproto,
    "ssl_gc_state.proto",
    &descriptor_table_ssl_5fgc_5fstate_2eproto_once, descriptor_table_ssl_5fgc_5fstate_2eproto_deps, 6, 10,
    schemas, file_default_instances, TableStruct_ssl_5fgc_5fstate_2eproto::offsets,
    file_level_metadata_ssl_5fgc_5fstate_2eproto, file_level_enum_descriptors_ssl_5fgc_5fstate_2eproto,
    file_level_service_descriptors_ssl_5fgc_5fstate_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ssl_5fgc_5fstate_2eproto_getter() {
  return &descriptor_table_ssl_5fgc_5fstate_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ssl_5fgc_5fstate_2eproto(&descriptor_table_ssl_5fgc_5fstate_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ssl_5fgc_5fstate_2eproto);
  return file_level_enum_descriptors_ssl_5fgc_5fstate_2eproto[0];
}
bool Command_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Command_Type Command::UNKNOWN;
constexpr Command_Type Command::HALT;
constexpr Command_Type Command::STOP;
constexpr Command_Type Command::NORMAL_START;
constexpr Command_Type Command::FORCE_START;
constexpr Command_Type Command::DIRECT;
constexpr Command_Type Command::INDIRECT;
constexpr Command_Type Command::KICKOFF;
constexpr Command_Type Command::PENALTY;
constexpr Command_Type Command::TIMEOUT;
constexpr Command_Type Command::BALL_PLACEMENT;
constexpr Command_Type Command::Type_MIN;
constexpr Command_Type Command::Type_MAX;
constexpr int Command::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameState_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ssl_5fgc_5fstate_2eproto);
  return file_level_enum_descriptors_ssl_5fgc_5fstate_2eproto[1];
}
bool GameState_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GameState_Type GameState::UNKNOWN;
constexpr GameState_Type GameState::HALT;
constexpr GameState_Type GameState::STOP;
constexpr GameState_Type GameState::RUNNING;
constexpr GameState_Type GameState::FREE_KICK;
constexpr GameState_Type GameState::KICKOFF;
constexpr GameState_Type GameState::PENALTY;
constexpr GameState_Type GameState::TIMEOUT;
constexpr GameState_Type GameState::BALL_PLACEMENT;
constexpr GameState_Type GameState::Type_MIN;
constexpr GameState_Type GameState::Type_MAX;
constexpr int GameState::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class YellowCard::_Internal {
 public:
  using HasBits = decltype(std::declval<YellowCard>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::GameEvent& caused_by_game_event(const YellowCard* msg);
  static void set_has_caused_by_game_event(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& time_remaining(const YellowCard* msg);
  static void set_has_time_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::GameEvent&
YellowCard::_Internal::caused_by_game_event(const YellowCard* msg) {
  return *msg->_impl_.caused_by_game_event_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
YellowCard::_Internal::time_remaining(const YellowCard* msg) {
  return *msg->_impl_.time_remaining_;
}
void YellowCard::clear_caused_by_game_event() {
  if (_impl_.caused_by_game_event_ != nullptr) _impl_.caused_by_game_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void YellowCard::clear_time_remaining() {
  if (_impl_.time_remaining_ != nullptr) _impl_.time_remaining_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
YellowCard::YellowCard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:YellowCard)
}
YellowCard::YellowCard(const YellowCard& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  YellowCard* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caused_by_game_event_){nullptr}
    , decltype(_impl_.time_remaining_){nullptr}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_caused_by_game_event()) {
    _this->_impl_.caused_by_game_event_ = new ::GameEvent(*from._impl_.caused_by_game_event_);
  }
  if (from._internal_has_time_remaining()) {
    _this->_impl_.time_remaining_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.time_remaining_);
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:YellowCard)
}

inline void YellowCard::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caused_by_game_event_){nullptr}
    , decltype(_impl_.time_remaining_){nullptr}
    , decltype(_impl_.id_){0u}
  };
}

YellowCard::~YellowCard() {
  // @@protoc_insertion_point(destructor:YellowCard)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void YellowCard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.caused_by_game_event_;
  if (this != internal_default_instance()) delete _impl_.time_remaining_;
}

void YellowCard::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void YellowCard::Clear() {
// @@protoc_insertion_point(message_clear_start:YellowCard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.caused_by_game_event_ != nullptr);
      _impl_.caused_by_game_event_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.time_remaining_ != nullptr);
      _impl_.time_remaining_->Clear();
    }
  }
  _impl_.id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* YellowCard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameEvent caused_by_game_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_caused_by_game_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration time_remaining = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_remaining(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* YellowCard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:YellowCard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional .GameEvent caused_by_game_event = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::caused_by_game_event(this),
        _Internal::caused_by_game_event(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration time_remaining = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::time_remaining(this),
        _Internal::time_remaining(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:YellowCard)
  return target;
}

size_t YellowCard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:YellowCard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .GameEvent caused_by_game_event = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.caused_by_game_event_);
    }

    // optional .google.protobuf.Duration time_remaining = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_remaining_);
    }

    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData YellowCard::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    YellowCard::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*YellowCard::GetClassData() const { return &_class_data_; }


void YellowCard::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<YellowCard*>(&to_msg);
  auto& from = static_cast<const YellowCard&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:YellowCard)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_caused_by_game_event()->::GameEvent::MergeFrom(
          from._internal_caused_by_game_event());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_time_remaining()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_time_remaining());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void YellowCard::CopyFrom(const YellowCard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:YellowCard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool YellowCard::IsInitialized() const {
  if (_internal_has_caused_by_game_event()) {
    if (!_impl_.caused_by_game_event_->IsInitialized()) return false;
  }
  return true;
}

void YellowCard::InternalSwap(YellowCard* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(YellowCard, _impl_.id_)
      + sizeof(YellowCard::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(YellowCard, _impl_.caused_by_game_event_)>(
          reinterpret_cast<char*>(&_impl_.caused_by_game_event_),
          reinterpret_cast<char*>(&other->_impl_.caused_by_game_event_));
}

::PROTOBUF_NAMESPACE_ID::Metadata YellowCard::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[0]);
}

// ===================================================================

class RedCard::_Internal {
 public:
  using HasBits = decltype(std::declval<RedCard>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::GameEvent& caused_by_game_event(const RedCard* msg);
  static void set_has_caused_by_game_event(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::GameEvent&
RedCard::_Internal::caused_by_game_event(const RedCard* msg) {
  return *msg->_impl_.caused_by_game_event_;
}
void RedCard::clear_caused_by_game_event() {
  if (_impl_.caused_by_game_event_ != nullptr) _impl_.caused_by_game_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RedCard::RedCard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RedCard)
}
RedCard::RedCard(const RedCard& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RedCard* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caused_by_game_event_){nullptr}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_caused_by_game_event()) {
    _this->_impl_.caused_by_game_event_ = new ::GameEvent(*from._impl_.caused_by_game_event_);
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:RedCard)
}

inline void RedCard::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caused_by_game_event_){nullptr}
    , decltype(_impl_.id_){0u}
  };
}

RedCard::~RedCard() {
  // @@protoc_insertion_point(destructor:RedCard)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RedCard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.caused_by_game_event_;
}

void RedCard::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RedCard::Clear() {
// @@protoc_insertion_point(message_clear_start:RedCard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.caused_by_game_event_ != nullptr);
    _impl_.caused_by_game_event_->Clear();
  }
  _impl_.id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RedCard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameEvent caused_by_game_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_caused_by_game_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RedCard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RedCard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional .GameEvent caused_by_game_event = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::caused_by_game_event(this),
        _Internal::caused_by_game_event(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RedCard)
  return target;
}

size_t RedCard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RedCard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .GameEvent caused_by_game_event = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.caused_by_game_event_);
    }

    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RedCard::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RedCard::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RedCard::GetClassData() const { return &_class_data_; }


void RedCard::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RedCard*>(&to_msg);
  auto& from = static_cast<const RedCard&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RedCard)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_caused_by_game_event()->::GameEvent::MergeFrom(
          from._internal_caused_by_game_event());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RedCard::CopyFrom(const RedCard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RedCard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RedCard::IsInitialized() const {
  if (_internal_has_caused_by_game_event()) {
    if (!_impl_.caused_by_game_event_->IsInitialized()) return false;
  }
  return true;
}

void RedCard::InternalSwap(RedCard* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RedCard, _impl_.id_)
      + sizeof(RedCard::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(RedCard, _impl_.caused_by_game_event_)>(
          reinterpret_cast<char*>(&_impl_.caused_by_game_event_),
          reinterpret_cast<char*>(&other->_impl_.caused_by_game_event_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RedCard::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[1]);
}

// ===================================================================

class Foul::_Internal {
 public:
  using HasBits = decltype(std::declval<Foul>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::GameEvent& caused_by_game_event(const Foul* msg);
  static void set_has_caused_by_game_event(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const Foul* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::GameEvent&
Foul::_Internal::caused_by_game_event(const Foul* msg) {
  return *msg->_impl_.caused_by_game_event_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Foul::_Internal::timestamp(const Foul* msg) {
  return *msg->_impl_.timestamp_;
}
void Foul::clear_caused_by_game_event() {
  if (_impl_.caused_by_game_event_ != nullptr) _impl_.caused_by_game_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Foul::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
Foul::Foul(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Foul)
}
Foul::Foul(const Foul& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Foul* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caused_by_game_event_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_caused_by_game_event()) {
    _this->_impl_.caused_by_game_event_ = new ::GameEvent(*from._impl_.caused_by_game_event_);
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Foul)
}

inline void Foul::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caused_by_game_event_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.id_){0u}
  };
}

Foul::~Foul() {
  // @@protoc_insertion_point(destructor:Foul)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Foul::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.caused_by_game_event_;
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void Foul::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Foul::Clear() {
// @@protoc_insertion_point(message_clear_start:Foul)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.caused_by_game_event_ != nullptr);
      _impl_.caused_by_game_event_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
  }
  _impl_.id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Foul::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameEvent caused_by_game_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_caused_by_game_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Foul::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Foul)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional .GameEvent caused_by_game_event = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::caused_by_game_event(this),
        _Internal::caused_by_game_event(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp timestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Foul)
  return target;
}

size_t Foul::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Foul)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .GameEvent caused_by_game_event = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.caused_by_game_event_);
    }

    // optional .google.protobuf.Timestamp timestamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Foul::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Foul::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Foul::GetClassData() const { return &_class_data_; }


void Foul::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Foul*>(&to_msg);
  auto& from = static_cast<const Foul&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Foul)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_caused_by_game_event()->::GameEvent::MergeFrom(
          from._internal_caused_by_game_event());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Foul::CopyFrom(const Foul& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Foul)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Foul::IsInitialized() const {
  if (_internal_has_caused_by_game_event()) {
    if (!_impl_.caused_by_game_event_->IsInitialized()) return false;
  }
  return true;
}

void Foul::InternalSwap(Foul* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Foul, _impl_.id_)
      + sizeof(Foul::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(Foul, _impl_.caused_by_game_event_)>(
          reinterpret_cast<char*>(&_impl_.caused_by_game_event_),
          reinterpret_cast<char*>(&other->_impl_.caused_by_game_event_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Foul::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[2]);
}

// ===================================================================

class Command::_Internal {
 public:
  using HasBits = decltype(std::declval<Command>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_for_team(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Command::Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command)
}
Command::Command(const Command& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Command* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.for_team_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.for_team_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.for_team_));
  // @@protoc_insertion_point(copy_constructor:Command)
}

inline void Command::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.for_team_){0}
  };
}

Command::~Command() {
  // @@protoc_insertion_point(destructor:Command)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Command::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Command::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Command::Clear() {
// @@protoc_insertion_point(message_clear_start:Command)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.for_team_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.for_team_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Command::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Command.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Command_Type_IsValid(val))) {
            _internal_set_type(static_cast<::Command_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .Team for_team = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Team_IsValid(val))) {
            _internal_set_for_team(static_cast<::Team>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Command::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Command.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .Team for_team = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_for_team(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command)
  return target;
}

size_t Command::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command)
  size_t total_size = 0;

  // required .Command.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Team for_team = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_for_team());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Command::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Command::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Command::GetClassData() const { return &_class_data_; }


void Command::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Command*>(&to_msg);
  auto& from = static_cast<const Command&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.for_team_ = from._impl_.for_team_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Command::CopyFrom(const Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Command::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Command::InternalSwap(Command* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Command, _impl_.for_team_)
      + sizeof(Command::_impl_.for_team_)
      - PROTOBUF_FIELD_OFFSET(Command, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Command::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[3]);
}

// ===================================================================

class GameState::_Internal {
 public:
  using HasBits = decltype(std::declval<GameState>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_for_team(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GameState::GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:GameState)
}
GameState::GameState(const GameState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.for_team_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.for_team_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.for_team_));
  // @@protoc_insertion_point(copy_constructor:GameState)
}

inline void GameState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.for_team_){0}
  };
}

GameState::~GameState() {
  // @@protoc_insertion_point(destructor:GameState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameState::Clear() {
// @@protoc_insertion_point(message_clear_start:GameState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.for_team_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.for_team_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .GameState.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::GameState_Type_IsValid(val))) {
            _internal_set_type(static_cast<::GameState_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .Team for_team = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Team_IsValid(val))) {
            _internal_set_for_team(static_cast<::Team>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .GameState.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .Team for_team = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_for_team(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameState)
  return target;
}

size_t GameState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameState)
  size_t total_size = 0;

  // required .GameState.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Team for_team = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_for_team());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameState::GetClassData() const { return &_class_data_; }


void GameState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameState*>(&to_msg);
  auto& from = static_cast<const GameState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:GameState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.for_team_ = from._impl_.for_team_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameState::CopyFrom(const GameState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GameState::InternalSwap(GameState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameState, _impl_.for_team_)
      + sizeof(GameState::_impl_.for_team_)
      - PROTOBUF_FIELD_OFFSET(GameState, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[4]);
}

// ===================================================================

class Proposal::_Internal {
 public:
  using HasBits = decltype(std::declval<Proposal>()._impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const Proposal* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::GameEvent& game_event(const Proposal* msg);
  static void set_has_game_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Proposal::_Internal::timestamp(const Proposal* msg) {
  return *msg->_impl_.timestamp_;
}
const ::GameEvent&
Proposal::_Internal::game_event(const Proposal* msg) {
  return *msg->_impl_.game_event_;
}
void Proposal::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Proposal::clear_game_event() {
  if (_impl_.game_event_ != nullptr) _impl_.game_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
Proposal::Proposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proposal)
}
Proposal::Proposal(const Proposal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proposal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.game_event_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  if (from._internal_has_game_event()) {
    _this->_impl_.game_event_ = new ::GameEvent(*from._impl_.game_event_);
  }
  // @@protoc_insertion_point(copy_constructor:Proposal)
}

inline void Proposal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.game_event_){nullptr}
  };
}

Proposal::~Proposal() {
  // @@protoc_insertion_point(destructor:Proposal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proposal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.game_event_;
}

void Proposal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proposal::Clear() {
// @@protoc_insertion_point(message_clear_start:Proposal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.game_event_ != nullptr);
      _impl_.game_event_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proposal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .google.protobuf.Timestamp timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GameEvent game_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proposal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proposal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.protobuf.Timestamp timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // optional .GameEvent game_event = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::game_event(this),
        _Internal::game_event(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proposal)
  return target;
}

size_t Proposal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proposal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .google.protobuf.Timestamp timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional .GameEvent game_event = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.game_event_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proposal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proposal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proposal::GetClassData() const { return &_class_data_; }


void Proposal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proposal*>(&to_msg);
  auto& from = static_cast<const Proposal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proposal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_game_event()->::GameEvent::MergeFrom(
          from._internal_game_event());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proposal::CopyFrom(const Proposal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proposal::IsInitialized() const {
  if (_internal_has_game_event()) {
    if (!_impl_.game_event_->IsInitialized()) return false;
  }
  return true;
}

void Proposal::InternalSwap(Proposal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Proposal, _impl_.game_event_)
      + sizeof(Proposal::_impl_.game_event_)
      - PROTOBUF_FIELD_OFFSET(Proposal, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Proposal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[5]);
}

// ===================================================================

class ProposalGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<ProposalGroup>()._impl_._has_bits_);
  static void set_has_accepted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ProposalGroup::ProposalGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProposalGroup)
}
ProposalGroup::ProposalGroup(const ProposalGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProposalGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.proposals_){from._impl_.proposals_}
    , decltype(_impl_.accepted_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.accepted_ = from._impl_.accepted_;
  // @@protoc_insertion_point(copy_constructor:ProposalGroup)
}

inline void ProposalGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.proposals_){arena}
    , decltype(_impl_.accepted_){false}
  };
}

ProposalGroup::~ProposalGroup() {
  // @@protoc_insertion_point(destructor:ProposalGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProposalGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proposals_.~RepeatedPtrField();
}

void ProposalGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProposalGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:ProposalGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proposals_.Clear();
  _impl_.accepted_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProposalGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Proposal proposals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_proposals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool accepted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_accepted(&has_bits);
          _impl_.accepted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProposalGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProposalGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Proposal proposals = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_proposals_size()); i < n; i++) {
    const auto& repfield = this->_internal_proposals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool accepted = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_accepted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProposalGroup)
  return target;
}

size_t ProposalGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProposalGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Proposal proposals = 1;
  total_size += 1UL * this->_internal_proposals_size();
  for (const auto& msg : this->_impl_.proposals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool accepted = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProposalGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProposalGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProposalGroup::GetClassData() const { return &_class_data_; }


void ProposalGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProposalGroup*>(&to_msg);
  auto& from = static_cast<const ProposalGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProposalGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.proposals_.MergeFrom(from._impl_.proposals_);
  if (from._internal_has_accepted()) {
    _this->_internal_set_accepted(from._internal_accepted());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProposalGroup::CopyFrom(const ProposalGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProposalGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProposalGroup::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.proposals_))
    return false;
  return true;
}

void ProposalGroup::InternalSwap(ProposalGroup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.proposals_.InternalSwap(&other->_impl_.proposals_);
  swap(_impl_.accepted_, other->_impl_.accepted_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProposalGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[6]);
}

// ===================================================================

class TeamInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TeamInfo>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_goals(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goalkeeper(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timeouts_left(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& timeout_time_left(const TeamInfo* msg);
  static void set_has_timeout_time_left(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_on_positive_half(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ball_placement_failures(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_ball_placement_failures_reached(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_can_place_ball(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_max_allowed_bots(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& requests_bot_substitution_since(const TeamInfo* msg);
  static void set_has_requests_bot_substitution_since(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& requests_timeout_since(const TeamInfo* msg);
  static void set_has_requests_timeout_since(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& requests_emergency_stop_since(const TeamInfo* msg);
  static void set_has_requests_emergency_stop_since(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_challenge_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Duration&
TeamInfo::_Internal::timeout_time_left(const TeamInfo* msg) {
  return *msg->_impl_.timeout_time_left_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TeamInfo::_Internal::requests_bot_substitution_since(const TeamInfo* msg) {
  return *msg->_impl_.requests_bot_substitution_since_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TeamInfo::_Internal::requests_timeout_since(const TeamInfo* msg) {
  return *msg->_impl_.requests_timeout_since_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TeamInfo::_Internal::requests_emergency_stop_since(const TeamInfo* msg) {
  return *msg->_impl_.requests_emergency_stop_since_;
}
void TeamInfo::clear_timeout_time_left() {
  if (_impl_.timeout_time_left_ != nullptr) _impl_.timeout_time_left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TeamInfo::clear_requests_bot_substitution_since() {
  if (_impl_.requests_bot_substitution_since_ != nullptr) _impl_.requests_bot_substitution_since_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TeamInfo::clear_requests_timeout_since() {
  if (_impl_.requests_timeout_since_ != nullptr) _impl_.requests_timeout_since_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TeamInfo::clear_requests_emergency_stop_since() {
  if (_impl_.requests_emergency_stop_since_ != nullptr) _impl_.requests_emergency_stop_since_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
TeamInfo::TeamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TeamInfo)
}
TeamInfo::TeamInfo(const TeamInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TeamInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.yellow_cards_){from._impl_.yellow_cards_}
    , decltype(_impl_.red_cards_){from._impl_.red_cards_}
    , decltype(_impl_.fouls_){from._impl_.fouls_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.timeout_time_left_){nullptr}
    , decltype(_impl_.requests_bot_substitution_since_){nullptr}
    , decltype(_impl_.requests_timeout_since_){nullptr}
    , decltype(_impl_.requests_emergency_stop_since_){nullptr}
    , decltype(_impl_.goals_){}
    , decltype(_impl_.goalkeeper_){}
    , decltype(_impl_.timeouts_left_){}
    , decltype(_impl_.ball_placement_failures_){}
    , decltype(_impl_.on_positive_half_){}
    , decltype(_impl_.ball_placement_failures_reached_){}
    , decltype(_impl_.can_place_ball_){}
    , decltype(_impl_.max_allowed_bots_){}
    , decltype(_impl_.challenge_flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_timeout_time_left()) {
    _this->_impl_.timeout_time_left_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.timeout_time_left_);
  }
  if (from._internal_has_requests_bot_substitution_since()) {
    _this->_impl_.requests_bot_substitution_since_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.requests_bot_substitution_since_);
  }
  if (from._internal_has_requests_timeout_since()) {
    _this->_impl_.requests_timeout_since_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.requests_timeout_since_);
  }
  if (from._internal_has_requests_emergency_stop_since()) {
    _this->_impl_.requests_emergency_stop_since_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.requests_emergency_stop_since_);
  }
  ::memcpy(&_impl_.goals_, &from._impl_.goals_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.challenge_flags_) -
    reinterpret_cast<char*>(&_impl_.goals_)) + sizeof(_impl_.challenge_flags_));
  // @@protoc_insertion_point(copy_constructor:TeamInfo)
}

inline void TeamInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.yellow_cards_){arena}
    , decltype(_impl_.red_cards_){arena}
    , decltype(_impl_.fouls_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.timeout_time_left_){nullptr}
    , decltype(_impl_.requests_bot_substitution_since_){nullptr}
    , decltype(_impl_.requests_timeout_since_){nullptr}
    , decltype(_impl_.requests_emergency_stop_since_){nullptr}
    , decltype(_impl_.goals_){0}
    , decltype(_impl_.goalkeeper_){0}
    , decltype(_impl_.timeouts_left_){0}
    , decltype(_impl_.ball_placement_failures_){0}
    , decltype(_impl_.on_positive_half_){false}
    , decltype(_impl_.ball_placement_failures_reached_){false}
    , decltype(_impl_.can_place_ball_){false}
    , decltype(_impl_.max_allowed_bots_){0}
    , decltype(_impl_.challenge_flags_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TeamInfo::~TeamInfo() {
  // @@protoc_insertion_point(destructor:TeamInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TeamInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.yellow_cards_.~RepeatedPtrField();
  _impl_.red_cards_.~RepeatedPtrField();
  _impl_.fouls_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timeout_time_left_;
  if (this != internal_default_instance()) delete _impl_.requests_bot_substitution_since_;
  if (this != internal_default_instance()) delete _impl_.requests_timeout_since_;
  if (this != internal_default_instance()) delete _impl_.requests_emergency_stop_since_;
}

void TeamInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TeamInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:TeamInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.yellow_cards_.Clear();
  _impl_.red_cards_.Clear();
  _impl_.fouls_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.timeout_time_left_ != nullptr);
      _impl_.timeout_time_left_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.requests_bot_substitution_since_ != nullptr);
      _impl_.requests_bot_substitution_since_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.requests_timeout_since_ != nullptr);
      _impl_.requests_timeout_since_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.requests_emergency_stop_since_ != nullptr);
      _impl_.requests_emergency_stop_since_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.goals_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timeouts_left_) -
        reinterpret_cast<char*>(&_impl_.goals_)) + sizeof(_impl_.timeouts_left_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.ball_placement_failures_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.challenge_flags_) -
        reinterpret_cast<char*>(&_impl_.ball_placement_failures_)) + sizeof(_impl_.challenge_flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TeamInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TeamInfo.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 goals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_goals(&has_bits);
          _impl_.goals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 goalkeeper = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_goalkeeper(&has_bits);
          _impl_.goalkeeper_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .YellowCard yellow_cards = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_yellow_cards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .RedCard red_cards = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_red_cards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 timeouts_left = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_timeouts_left(&has_bits);
          _impl_.timeouts_left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration timeout_time_left = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_timeout_time_left(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool on_positive_half = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_on_positive_half(&has_bits);
          _impl_.on_positive_half_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Foul fouls = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fouls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 ball_placement_failures = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_ball_placement_failures(&has_bits);
          _impl_.ball_placement_failures_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ball_placement_failures_reached = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_ball_placement_failures_reached(&has_bits);
          _impl_.ball_placement_failures_reached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool can_place_ball = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_can_place_ball(&has_bits);
          _impl_.can_place_ball_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_allowed_bots = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_max_allowed_bots(&has_bits);
          _impl_.max_allowed_bots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp requests_bot_substitution_since = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_requests_bot_substitution_since(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp requests_timeout_since = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_requests_timeout_since(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp requests_emergency_stop_since = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_requests_emergency_stop_since(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 challenge_flags = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_challenge_flags(&has_bits);
          _impl_.challenge_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TeamInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TeamInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TeamInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 goals = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_goals(), target);
  }

  // optional int32 goalkeeper = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_goalkeeper(), target);
  }

  // repeated .YellowCard yellow_cards = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_yellow_cards_size()); i < n; i++) {
    const auto& repfield = this->_internal_yellow_cards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .RedCard red_cards = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_red_cards_size()); i < n; i++) {
    const auto& repfield = this->_internal_red_cards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 timeouts_left = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_timeouts_left(), target);
  }

  // optional .google.protobuf.Duration timeout_time_left = 7;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::timeout_time_left(this),
        _Internal::timeout_time_left(this).GetCachedSize(), target, stream);
  }

  // optional bool on_positive_half = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_on_positive_half(), target);
  }

  // repeated .Foul fouls = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fouls_size()); i < n; i++) {
    const auto& repfield = this->_internal_fouls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 ball_placement_failures = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_ball_placement_failures(), target);
  }

  // optional bool ball_placement_failures_reached = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_ball_placement_failures_reached(), target);
  }

  // optional bool can_place_ball = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_can_place_ball(), target);
  }

  // optional int32 max_allowed_bots = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_max_allowed_bots(), target);
  }

  // optional .google.protobuf.Timestamp requests_bot_substitution_since = 14;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::requests_bot_substitution_since(this),
        _Internal::requests_bot_substitution_since(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp requests_timeout_since = 15;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::requests_timeout_since(this),
        _Internal::requests_timeout_since(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp requests_emergency_stop_since = 16;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::requests_emergency_stop_since(this),
        _Internal::requests_emergency_stop_since(this).GetCachedSize(), target, stream);
  }

  // optional int32 challenge_flags = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_challenge_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TeamInfo)
  return target;
}

size_t TeamInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TeamInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .YellowCard yellow_cards = 4;
  total_size += 1UL * this->_internal_yellow_cards_size();
  for (const auto& msg : this->_impl_.yellow_cards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .RedCard red_cards = 5;
  total_size += 1UL * this->_internal_red_cards_size();
  for (const auto& msg : this->_impl_.red_cards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Foul fouls = 9;
  total_size += 1UL * this->_internal_fouls_size();
  for (const auto& msg : this->_impl_.fouls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .google.protobuf.Duration timeout_time_left = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timeout_time_left_);
    }

    // optional .google.protobuf.Timestamp requests_bot_substitution_since = 14;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_bot_substitution_since_);
    }

    // optional .google.protobuf.Timestamp requests_timeout_since = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_timeout_since_);
    }

    // optional .google.protobuf.Timestamp requests_emergency_stop_since = 16;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_emergency_stop_since_);
    }

    // optional int32 goals = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_goals());
    }

    // optional int32 goalkeeper = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_goalkeeper());
    }

    // optional int32 timeouts_left = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeouts_left());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional int32 ball_placement_failures = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ball_placement_failures());
    }

    // optional bool on_positive_half = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool ball_placement_failures_reached = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool can_place_ball = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional int32 max_allowed_bots = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_allowed_bots());
    }

    // optional int32 challenge_flags = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_challenge_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TeamInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TeamInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TeamInfo::GetClassData() const { return &_class_data_; }


void TeamInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TeamInfo*>(&to_msg);
  auto& from = static_cast<const TeamInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TeamInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.yellow_cards_.MergeFrom(from._impl_.yellow_cards_);
  _this->_impl_.red_cards_.MergeFrom(from._impl_.red_cards_);
  _this->_impl_.fouls_.MergeFrom(from._impl_.fouls_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_timeout_time_left()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_timeout_time_left());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_requests_bot_substitution_since()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_requests_bot_substitution_since());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_requests_timeout_since()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_requests_timeout_since());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_requests_emergency_stop_since()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_requests_emergency_stop_since());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.goals_ = from._impl_.goals_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.goalkeeper_ = from._impl_.goalkeeper_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.timeouts_left_ = from._impl_.timeouts_left_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.ball_placement_failures_ = from._impl_.ball_placement_failures_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.on_positive_half_ = from._impl_.on_positive_half_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.ball_placement_failures_reached_ = from._impl_.ball_placement_failures_reached_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.can_place_ball_ = from._impl_.can_place_ball_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.max_allowed_bots_ = from._impl_.max_allowed_bots_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.challenge_flags_ = from._impl_.challenge_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TeamInfo::CopyFrom(const TeamInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TeamInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeamInfo::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.yellow_cards_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.red_cards_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.fouls_))
    return false;
  return true;
}

void TeamInfo::InternalSwap(TeamInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.yellow_cards_.InternalSwap(&other->_impl_.yellow_cards_);
  _impl_.red_cards_.InternalSwap(&other->_impl_.red_cards_);
  _impl_.fouls_.InternalSwap(&other->_impl_.fouls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TeamInfo, _impl_.challenge_flags_)
      + sizeof(TeamInfo::_impl_.challenge_flags_)
      - PROTOBUF_FIELD_OFFSET(TeamInfo, _impl_.timeout_time_left_)>(
          reinterpret_cast<char*>(&_impl_.timeout_time_left_),
          reinterpret_cast<char*>(&other->_impl_.timeout_time_left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TeamInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[7]);
}

// ===================================================================

State_TeamStateEntry_DoNotUse::State_TeamStateEntry_DoNotUse() {}
State_TeamStateEntry_DoNotUse::State_TeamStateEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void State_TeamStateEntry_DoNotUse::MergeFrom(const State_TeamStateEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata State_TeamStateEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[8]);
}

// ===================================================================

class State::_Internal {
 public:
  using HasBits = decltype(std::declval<State>()._impl_._has_bits_);
  static void set_has_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::Command& command(const State* msg);
  static void set_has_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::GameState& game_state(const State* msg);
  static void set_has_game_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& stage_time_elapsed(const State* msg);
  static void set_has_stage_time_elapsed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& stage_time_left(const State* msg);
  static void set_has_stage_time_left(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& match_time_start(const State* msg);
  static void set_has_match_time_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::Vector2& placement_pos(const State* msg);
  static void set_has_placement_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::Command& next_command(const State* msg);
  static void set_has_next_command(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& current_action_time_remaining(const State* msg);
  static void set_has_current_action_time_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_division(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_auto_continue(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_first_kickoff_team(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_match_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

const ::Command&
State::_Internal::command(const State* msg) {
  return *msg->_impl_.command_;
}
const ::GameState&
State::_Internal::game_state(const State* msg) {
  return *msg->_impl_.game_state_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
State::_Internal::stage_time_elapsed(const State* msg) {
  return *msg->_impl_.stage_time_elapsed_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
State::_Internal::stage_time_left(const State* msg) {
  return *msg->_impl_.stage_time_left_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
State::_Internal::match_time_start(const State* msg) {
  return *msg->_impl_.match_time_start_;
}
const ::Vector2&
State::_Internal::placement_pos(const State* msg) {
  return *msg->_impl_.placement_pos_;
}
const ::Command&
State::_Internal::next_command(const State* msg) {
  return *msg->_impl_.next_command_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
State::_Internal::current_action_time_remaining(const State* msg) {
  return *msg->_impl_.current_action_time_remaining_;
}
void State::clear_stage_time_elapsed() {
  if (_impl_.stage_time_elapsed_ != nullptr) _impl_.stage_time_elapsed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void State::clear_stage_time_left() {
  if (_impl_.stage_time_left_ != nullptr) _impl_.stage_time_left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void State::clear_match_time_start() {
  if (_impl_.match_time_start_ != nullptr) _impl_.match_time_start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void State::clear_placement_pos() {
  if (_impl_.placement_pos_ != nullptr) _impl_.placement_pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void State::clear_current_action_time_remaining() {
  if (_impl_.current_action_time_remaining_ != nullptr) _impl_.current_action_time_remaining_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void State::clear_game_events() {
  _impl_.game_events_.Clear();
}
State::State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &State::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:State)
}
State::State(const State& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  State* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.team_state_)*/{}
    , decltype(_impl_.game_events_){from._impl_.game_events_}
    , decltype(_impl_.proposal_groups_){from._impl_.proposal_groups_}
    , decltype(_impl_.command_){nullptr}
    , decltype(_impl_.stage_time_elapsed_){nullptr}
    , decltype(_impl_.stage_time_left_){nullptr}
    , decltype(_impl_.match_time_start_){nullptr}
    , decltype(_impl_.placement_pos_){nullptr}
    , decltype(_impl_.next_command_){nullptr}
    , decltype(_impl_.current_action_time_remaining_){nullptr}
    , decltype(_impl_.game_state_){nullptr}
    , decltype(_impl_.stage_){}
    , decltype(_impl_.division_){}
    , decltype(_impl_.auto_continue_){}
    , decltype(_impl_.first_kickoff_team_){}
    , decltype(_impl_.match_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.team_state_.MergeFrom(from._impl_.team_state_);
  if (from._internal_has_command()) {
    _this->_impl_.command_ = new ::Command(*from._impl_.command_);
  }
  if (from._internal_has_stage_time_elapsed()) {
    _this->_impl_.stage_time_elapsed_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.stage_time_elapsed_);
  }
  if (from._internal_has_stage_time_left()) {
    _this->_impl_.stage_time_left_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.stage_time_left_);
  }
  if (from._internal_has_match_time_start()) {
    _this->_impl_.match_time_start_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.match_time_start_);
  }
  if (from._internal_has_placement_pos()) {
    _this->_impl_.placement_pos_ = new ::Vector2(*from._impl_.placement_pos_);
  }
  if (from._internal_has_next_command()) {
    _this->_impl_.next_command_ = new ::Command(*from._impl_.next_command_);
  }
  if (from._internal_has_current_action_time_remaining()) {
    _this->_impl_.current_action_time_remaining_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.current_action_time_remaining_);
  }
  if (from._internal_has_game_state()) {
    _this->_impl_.game_state_ = new ::GameState(*from._impl_.game_state_);
  }
  ::memcpy(&_impl_.stage_, &from._impl_.stage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.match_type_) -
    reinterpret_cast<char*>(&_impl_.stage_)) + sizeof(_impl_.match_type_));
  // @@protoc_insertion_point(copy_constructor:State)
}

inline void State::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.team_state_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.game_events_){arena}
    , decltype(_impl_.proposal_groups_){arena}
    , decltype(_impl_.command_){nullptr}
    , decltype(_impl_.stage_time_elapsed_){nullptr}
    , decltype(_impl_.stage_time_left_){nullptr}
    , decltype(_impl_.match_time_start_){nullptr}
    , decltype(_impl_.placement_pos_){nullptr}
    , decltype(_impl_.next_command_){nullptr}
    , decltype(_impl_.current_action_time_remaining_){nullptr}
    , decltype(_impl_.game_state_){nullptr}
    , decltype(_impl_.stage_){0}
    , decltype(_impl_.division_){0}
    , decltype(_impl_.auto_continue_){false}
    , decltype(_impl_.first_kickoff_team_){0}
    , decltype(_impl_.match_type_){0}
  };
}

State::~State() {
  // @@protoc_insertion_point(destructor:State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void State::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.team_state_.Destruct();
  _impl_.team_state_.~MapField();
  _impl_.game_events_.~RepeatedPtrField();
  _impl_.proposal_groups_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.command_;
  if (this != internal_default_instance()) delete _impl_.stage_time_elapsed_;
  if (this != internal_default_instance()) delete _impl_.stage_time_left_;
  if (this != internal_default_instance()) delete _impl_.match_time_start_;
  if (this != internal_default_instance()) delete _impl_.placement_pos_;
  if (this != internal_default_instance()) delete _impl_.next_command_;
  if (this != internal_default_instance()) delete _impl_.current_action_time_remaining_;
  if (this != internal_default_instance()) delete _impl_.game_state_;
}

void State::ArenaDtor(void* object) {
  State* _this = reinterpret_cast< State* >(object);
  _this->_impl_.team_state_.Destruct();
}
void State::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void State::Clear() {
// @@protoc_insertion_point(message_clear_start:State)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.team_state_.Clear();
  _impl_.game_events_.Clear();
  _impl_.proposal_groups_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.command_ != nullptr);
      _impl_.command_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.stage_time_elapsed_ != nullptr);
      _impl_.stage_time_elapsed_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.stage_time_left_ != nullptr);
      _impl_.stage_time_left_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.match_time_start_ != nullptr);
      _impl_.match_time_start_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.placement_pos_ != nullptr);
      _impl_.placement_pos_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.next_command_ != nullptr);
      _impl_.next_command_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.current_action_time_remaining_ != nullptr);
      _impl_.current_action_time_remaining_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.game_state_ != nullptr);
      _impl_.game_state_->Clear();
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.stage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.match_type_) -
        reinterpret_cast<char*>(&_impl_.stage_)) + sizeof(_impl_.match_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .Referee.Stage stage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Referee_Stage_IsValid(val))) {
            _internal_set_stage(static_cast<::Referee_Stage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .Command command = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration stage_time_elapsed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stage_time_elapsed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration stage_time_left = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_stage_time_left(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp match_time_start = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_time_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .TeamInfo> team_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.team_state_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .Vector2 placement_pos = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_placement_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Command next_command = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_next_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration current_action_time_remaining = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_current_action_time_remaining(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .GameEvent game_events = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_game_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ProposalGroup proposal_groups = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_proposal_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .Division division = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Division_IsValid(val))) {
            _internal_set_division(static_cast<::Division>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool auto_continue = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_auto_continue(&has_bits);
          _impl_.auto_continue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Team first_kickoff_team = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Team_IsValid(val))) {
            _internal_set_first_kickoff_team(static_cast<::Team>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .MatchType match_type = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::MatchType_IsValid(val))) {
            _internal_set_match_type(static_cast<::MatchType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .GameState game_state = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* State::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:State)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .Referee.Stage stage = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_stage(), target);
  }

  // optional .Command command = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::command(this),
        _Internal::command(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration stage_time_elapsed = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::stage_time_elapsed(this),
        _Internal::stage_time_elapsed(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration stage_time_left = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::stage_time_left(this),
        _Internal::stage_time_left(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp match_time_start = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::match_time_start(this),
        _Internal::match_time_start(this).GetCachedSize(), target, stream);
  }

  // map<string, .TeamInfo> team_state = 8;
  if (!this->_internal_team_state().empty()) {
    using MapType = ::_pb::Map<std::string, ::TeamInfo>;
    using WireHelper = State_TeamStateEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_team_state();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "State.TeamStateEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional .Vector2 placement_pos = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::placement_pos(this),
        _Internal::placement_pos(this).GetCachedSize(), target, stream);
  }

  // optional .Command next_command = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::next_command(this),
        _Internal::next_command(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Duration current_action_time_remaining = 12;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::current_action_time_remaining(this),
        _Internal::current_action_time_remaining(this).GetCachedSize(), target, stream);
  }

  // repeated .GameEvent game_events = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_game_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_game_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ProposalGroup proposal_groups = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_proposal_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_proposal_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .Division division = 15;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      15, this->_internal_division(), target);
  }

  // optional bool auto_continue = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_auto_continue(), target);
  }

  // optional .Team first_kickoff_team = 17;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_first_kickoff_team(), target);
  }

  // optional .MatchType match_type = 18;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_match_type(), target);
  }

  // optional .GameState game_state = 19;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::game_state(this),
        _Internal::game_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:State)
  return target;
}

size_t State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:State)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .TeamInfo> team_state = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_team_state_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TeamInfo >::const_iterator
      it = this->_internal_team_state().begin();
      it != this->_internal_team_state().end(); ++it) {
    total_size += State_TeamStateEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .GameEvent game_events = 13;
  total_size += 1UL * this->_internal_game_events_size();
  for (const auto& msg : this->_impl_.game_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ProposalGroup proposal_groups = 14;
  total_size += 1UL * this->_internal_proposal_groups_size();
  for (const auto& msg : this->_impl_.proposal_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .Command command = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_);
    }

    // optional .google.protobuf.Duration stage_time_elapsed = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stage_time_elapsed_);
    }

    // optional .google.protobuf.Duration stage_time_left = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stage_time_left_);
    }

    // optional .google.protobuf.Timestamp match_time_start = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.match_time_start_);
    }

    // optional .Vector2 placement_pos = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.placement_pos_);
    }

    // optional .Command next_command = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.next_command_);
    }

    // optional .google.protobuf.Duration current_action_time_remaining = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.current_action_time_remaining_);
    }

    // optional .GameState game_state = 19;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.game_state_);
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional .Referee.Stage stage = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_stage());
    }

    // optional .Division division = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_division());
    }

    // optional bool auto_continue = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional .Team first_kickoff_team = 17;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_first_kickoff_team());
    }

    // optional .MatchType match_type = 18;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_match_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData State::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    State::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*State::GetClassData() const { return &_class_data_; }


void State::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<State*>(&to_msg);
  auto& from = static_cast<const State&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:State)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.team_state_.MergeFrom(from._impl_.team_state_);
  _this->_impl_.game_events_.MergeFrom(from._impl_.game_events_);
  _this->_impl_.proposal_groups_.MergeFrom(from._impl_.proposal_groups_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_command()->::Command::MergeFrom(
          from._internal_command());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stage_time_elapsed()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_stage_time_elapsed());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_stage_time_left()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_stage_time_left());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_match_time_start()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_match_time_start());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_placement_pos()->::Vector2::MergeFrom(
          from._internal_placement_pos());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_next_command()->::Command::MergeFrom(
          from._internal_next_command());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_current_action_time_remaining()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_current_action_time_remaining());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_game_state()->::GameState::MergeFrom(
          from._internal_game_state());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.stage_ = from._impl_.stage_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.division_ = from._impl_.division_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.auto_continue_ = from._impl_.auto_continue_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.first_kickoff_team_ = from._impl_.first_kickoff_team_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.match_type_ = from._impl_.match_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void State::CopyFrom(const State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.team_state_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.game_events_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.proposal_groups_))
    return false;
  if (_internal_has_command()) {
    if (!_impl_.command_->IsInitialized()) return false;
  }
  if (_internal_has_placement_pos()) {
    if (!_impl_.placement_pos_->IsInitialized()) return false;
  }
  if (_internal_has_next_command()) {
    if (!_impl_.next_command_->IsInitialized()) return false;
  }
  if (_internal_has_game_state()) {
    if (!_impl_.game_state_->IsInitialized()) return false;
  }
  return true;
}

void State::InternalSwap(State* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.team_state_.InternalSwap(&other->_impl_.team_state_);
  _impl_.game_events_.InternalSwap(&other->_impl_.game_events_);
  _impl_.proposal_groups_.InternalSwap(&other->_impl_.proposal_groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(State, _impl_.match_type_)
      + sizeof(State::_impl_.match_type_)
      - PROTOBUF_FIELD_OFFSET(State, _impl_.command_)>(
          reinterpret_cast<char*>(&_impl_.command_),
          reinterpret_cast<char*>(&other->_impl_.command_));
}

::PROTOBUF_NAMESPACE_ID::Metadata State::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ssl_5fgc_5fstate_2eproto_getter, &descriptor_table_ssl_5fgc_5fstate_2eproto_once,
      file_level_metadata_ssl_5fgc_5fstate_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::YellowCard*
Arena::CreateMaybeMessage< ::YellowCard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::YellowCard >(arena);
}
template<> PROTOBUF_NOINLINE ::RedCard*
Arena::CreateMaybeMessage< ::RedCard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RedCard >(arena);
}
template<> PROTOBUF_NOINLINE ::Foul*
Arena::CreateMaybeMessage< ::Foul >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Foul >(arena);
}
template<> PROTOBUF_NOINLINE ::Command*
Arena::CreateMaybeMessage< ::Command >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command >(arena);
}
template<> PROTOBUF_NOINLINE ::GameState*
Arena::CreateMaybeMessage< ::GameState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameState >(arena);
}
template<> PROTOBUF_NOINLINE ::Proposal*
Arena::CreateMaybeMessage< ::Proposal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proposal >(arena);
}
template<> PROTOBUF_NOINLINE ::ProposalGroup*
Arena::CreateMaybeMessage< ::ProposalGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProposalGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::TeamInfo*
Arena::CreateMaybeMessage< ::TeamInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TeamInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::State_TeamStateEntry_DoNotUse*
Arena::CreateMaybeMessage< ::State_TeamStateEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::State_TeamStateEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::State*
Arena::CreateMaybeMessage< ::State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::State >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
