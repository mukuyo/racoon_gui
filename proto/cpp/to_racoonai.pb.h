// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: to_racoonai.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_to_5fracoonai_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_to_5fracoonai_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_to_5fracoonai_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_to_5fracoonai_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_to_5fracoonai_2eproto;
class Ball_Info;
struct Ball_InfoDefaultTypeInternal;
extern Ball_InfoDefaultTypeInternal _Ball_Info_default_instance_;
class Geometry_Info;
struct Geometry_InfoDefaultTypeInternal;
extern Geometry_InfoDefaultTypeInternal _Geometry_Info_default_instance_;
class Other_Infos;
struct Other_InfosDefaultTypeInternal;
extern Other_InfosDefaultTypeInternal _Other_Infos_default_instance_;
class RacoonMW_Packet;
struct RacoonMW_PacketDefaultTypeInternal;
extern RacoonMW_PacketDefaultTypeInternal _RacoonMW_Packet_default_instance_;
class Referee_Info;
struct Referee_InfoDefaultTypeInternal;
extern Referee_InfoDefaultTypeInternal _Referee_Info_default_instance_;
class RobotIP_Infos;
struct RobotIP_InfosDefaultTypeInternal;
extern RobotIP_InfosDefaultTypeInternal _RobotIP_Infos_default_instance_;
class Robot_Infos;
struct Robot_InfosDefaultTypeInternal;
extern Robot_InfosDefaultTypeInternal _Robot_Infos_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Ball_Info* Arena::CreateMaybeMessage<::Ball_Info>(Arena*);
template<> ::Geometry_Info* Arena::CreateMaybeMessage<::Geometry_Info>(Arena*);
template<> ::Other_Infos* Arena::CreateMaybeMessage<::Other_Infos>(Arena*);
template<> ::RacoonMW_Packet* Arena::CreateMaybeMessage<::RacoonMW_Packet>(Arena*);
template<> ::Referee_Info* Arena::CreateMaybeMessage<::Referee_Info>(Arena*);
template<> ::RobotIP_Infos* Arena::CreateMaybeMessage<::RobotIP_Infos>(Arena*);
template<> ::Robot_Infos* Arena::CreateMaybeMessage<::Robot_Infos>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Referee_Info_Command : int {
  Referee_Info_Command_HALT = 0,
  Referee_Info_Command_STOP = 1,
  Referee_Info_Command_NORMAL_START = 2,
  Referee_Info_Command_FORCE_START = 3,
  Referee_Info_Command_PREPARE_KICKOFF_YELLOW = 4,
  Referee_Info_Command_PREPARE_KICKOFF_BLUE = 5,
  Referee_Info_Command_PREPARE_PENALTY_YELLOW = 6,
  Referee_Info_Command_PREPARE_PENALTY_BLUE = 7,
  Referee_Info_Command_DIRECT_FREE_YELLOW = 8,
  Referee_Info_Command_DIRECT_FREE_BLUE = 9,
  Referee_Info_Command_INDIRECT_FREE_YELLOW = 10,
  Referee_Info_Command_INDIRECT_FREE_BLUE = 11,
  Referee_Info_Command_TIMEOUT_YELLOW = 12,
  Referee_Info_Command_TIMEOUT_BLUE = 13,
  Referee_Info_Command_GOAL_YELLOW PROTOBUF_DEPRECATED_ENUM = 14,
  Referee_Info_Command_GOAL_BLUE PROTOBUF_DEPRECATED_ENUM = 15,
  Referee_Info_Command_BALL_PLACEMENT_YELLOW = 16,
  Referee_Info_Command_BALL_PLACEMENT_BLUE = 17
};
bool Referee_Info_Command_IsValid(int value);
constexpr Referee_Info_Command Referee_Info_Command_Command_MIN = Referee_Info_Command_HALT;
constexpr Referee_Info_Command Referee_Info_Command_Command_MAX = Referee_Info_Command_BALL_PLACEMENT_BLUE;
constexpr int Referee_Info_Command_Command_ARRAYSIZE = Referee_Info_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Referee_Info_Command_descriptor();
template<typename T>
inline const std::string& Referee_Info_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Referee_Info_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Referee_Info_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Referee_Info_Command_descriptor(), enum_t_value);
}
inline bool Referee_Info_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Referee_Info_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Referee_Info_Command>(
    Referee_Info_Command_descriptor(), name, value);
}
enum Referee_Info_Stage : int {
  Referee_Info_Stage_NORMAL_FIRST_HALF_PRE = 0,
  Referee_Info_Stage_NORMAL_FIRST_HALF = 1,
  Referee_Info_Stage_NORMAL_HALF_TIME = 2,
  Referee_Info_Stage_NORMAL_SECOND_HALF_PRE = 3,
  Referee_Info_Stage_NORMAL_SECOND_HALF = 4,
  Referee_Info_Stage_EXTRA_TIME_BREAK = 5,
  Referee_Info_Stage_EXTRA_FIRST_HALF_PRE = 6,
  Referee_Info_Stage_EXTRA_FIRST_HALF = 7,
  Referee_Info_Stage_EXTRA_HALF_TIME = 8,
  Referee_Info_Stage_EXTRA_SECOND_HALF_PRE = 9,
  Referee_Info_Stage_EXTRA_SECOND_HALF = 10,
  Referee_Info_Stage_PENALTY_SHOOTOUT_BREAK = 11,
  Referee_Info_Stage_PENALTY_SHOOTOUT = 12,
  Referee_Info_Stage_POST_GAME = 13
};
bool Referee_Info_Stage_IsValid(int value);
constexpr Referee_Info_Stage Referee_Info_Stage_Stage_MIN = Referee_Info_Stage_NORMAL_FIRST_HALF_PRE;
constexpr Referee_Info_Stage Referee_Info_Stage_Stage_MAX = Referee_Info_Stage_POST_GAME;
constexpr int Referee_Info_Stage_Stage_ARRAYSIZE = Referee_Info_Stage_Stage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Referee_Info_Stage_descriptor();
template<typename T>
inline const std::string& Referee_Info_Stage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Referee_Info_Stage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Referee_Info_Stage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Referee_Info_Stage_descriptor(), enum_t_value);
}
inline bool Referee_Info_Stage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Referee_Info_Stage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Referee_Info_Stage>(
    Referee_Info_Stage_descriptor(), name, value);
}
// ===================================================================

class Robot_Infos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Robot_Infos) */ {
 public:
  inline Robot_Infos() : Robot_Infos(nullptr) {}
  ~Robot_Infos() override;
  explicit PROTOBUF_CONSTEXPR Robot_Infos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Infos(const Robot_Infos& from);
  Robot_Infos(Robot_Infos&& from) noexcept
    : Robot_Infos() {
    *this = ::std::move(from);
  }

  inline Robot_Infos& operator=(const Robot_Infos& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Infos& operator=(Robot_Infos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Infos& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Infos* internal_default_instance() {
    return reinterpret_cast<const Robot_Infos*>(
               &_Robot_Infos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Robot_Infos& a, Robot_Infos& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Infos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Infos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Infos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Infos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Infos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Robot_Infos& from) {
    Robot_Infos::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Infos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Robot_Infos";
  }
  protected:
  explicit Robot_Infos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kThetaFieldNumber = 4,
    kDistanceBallRobotFieldNumber = 5,
    kRadianBallRobotFieldNumber = 6,
    kDiffXFieldNumber = 7,
    kDiffYFieldNumber = 8,
    kDiffThetaFieldNumber = 9,
    kSpeedFieldNumber = 10,
    kSlopeFieldNumber = 11,
    kInterceptFieldNumber = 12,
    kAngularVelocityFieldNumber = 13,
    kVisibleFieldNumber = 14,
    kBallCatchFieldNumber = 15,
    kOnlineFieldNumber = 16,
    kBatteryVoltageFieldNumber = 17,
  };
  // required uint32 robot_id = 1;
  bool has_robot_id() const;
  private:
  bool _internal_has_robot_id() const;
  public:
  void clear_robot_id();
  uint32_t robot_id() const;
  void set_robot_id(uint32_t value);
  private:
  uint32_t _internal_robot_id() const;
  void _internal_set_robot_id(uint32_t value);
  public:

  // required float x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float theta = 4;
  bool has_theta() const;
  private:
  bool _internal_has_theta() const;
  public:
  void clear_theta();
  float theta() const;
  void set_theta(float value);
  private:
  float _internal_theta() const;
  void _internal_set_theta(float value);
  public:

  // optional float distance_ball_robot = 5;
  bool has_distance_ball_robot() const;
  private:
  bool _internal_has_distance_ball_robot() const;
  public:
  void clear_distance_ball_robot();
  float distance_ball_robot() const;
  void set_distance_ball_robot(float value);
  private:
  float _internal_distance_ball_robot() const;
  void _internal_set_distance_ball_robot(float value);
  public:

  // optional float radian_ball_robot = 6;
  bool has_radian_ball_robot() const;
  private:
  bool _internal_has_radian_ball_robot() const;
  public:
  void clear_radian_ball_robot();
  float radian_ball_robot() const;
  void set_radian_ball_robot(float value);
  private:
  float _internal_radian_ball_robot() const;
  void _internal_set_radian_ball_robot(float value);
  public:

  // required float diff_x = 7;
  bool has_diff_x() const;
  private:
  bool _internal_has_diff_x() const;
  public:
  void clear_diff_x();
  float diff_x() const;
  void set_diff_x(float value);
  private:
  float _internal_diff_x() const;
  void _internal_set_diff_x(float value);
  public:

  // required float diff_y = 8;
  bool has_diff_y() const;
  private:
  bool _internal_has_diff_y() const;
  public:
  void clear_diff_y();
  float diff_y() const;
  void set_diff_y(float value);
  private:
  float _internal_diff_y() const;
  void _internal_set_diff_y(float value);
  public:

  // required float diff_theta = 9;
  bool has_diff_theta() const;
  private:
  bool _internal_has_diff_theta() const;
  public:
  void clear_diff_theta();
  float diff_theta() const;
  void set_diff_theta(float value);
  private:
  float _internal_diff_theta() const;
  void _internal_set_diff_theta(float value);
  public:

  // required float speed = 10;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // required float slope = 11;
  bool has_slope() const;
  private:
  bool _internal_has_slope() const;
  public:
  void clear_slope();
  float slope() const;
  void set_slope(float value);
  private:
  float _internal_slope() const;
  void _internal_set_slope(float value);
  public:

  // required float intercept = 12;
  bool has_intercept() const;
  private:
  bool _internal_has_intercept() const;
  public:
  void clear_intercept();
  float intercept() const;
  void set_intercept(float value);
  private:
  float _internal_intercept() const;
  void _internal_set_intercept(float value);
  public:

  // required float angular_velocity = 13;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  float angular_velocity() const;
  void set_angular_velocity(float value);
  private:
  float _internal_angular_velocity() const;
  void _internal_set_angular_velocity(float value);
  public:

  // required bool visible = 14;
  bool has_visible() const;
  private:
  bool _internal_has_visible() const;
  public:
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // optional bool ball_catch = 15;
  bool has_ball_catch() const;
  private:
  bool _internal_has_ball_catch() const;
  public:
  void clear_ball_catch();
  bool ball_catch() const;
  void set_ball_catch(bool value);
  private:
  bool _internal_ball_catch() const;
  void _internal_set_ball_catch(bool value);
  public:

  // optional bool online = 16;
  bool has_online() const;
  private:
  bool _internal_has_online() const;
  public:
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // optional float battery_voltage = 17;
  bool has_battery_voltage() const;
  private:
  bool _internal_has_battery_voltage() const;
  public:
  void clear_battery_voltage();
  float battery_voltage() const;
  void set_battery_voltage(float value);
  private:
  float _internal_battery_voltage() const;
  void _internal_set_battery_voltage(float value);
  public:

  // @@protoc_insertion_point(class_scope:Robot_Infos)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t robot_id_;
    float x_;
    float y_;
    float theta_;
    float distance_ball_robot_;
    float radian_ball_robot_;
    float diff_x_;
    float diff_y_;
    float diff_theta_;
    float speed_;
    float slope_;
    float intercept_;
    float angular_velocity_;
    bool visible_;
    bool ball_catch_;
    bool online_;
    float battery_voltage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_to_5fracoonai_2eproto;
};
// -------------------------------------------------------------------

class Ball_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Ball_Info) */ {
 public:
  inline Ball_Info() : Ball_Info(nullptr) {}
  ~Ball_Info() override;
  explicit PROTOBUF_CONSTEXPR Ball_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ball_Info(const Ball_Info& from);
  Ball_Info(Ball_Info&& from) noexcept
    : Ball_Info() {
    *this = ::std::move(from);
  }

  inline Ball_Info& operator=(const Ball_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ball_Info& operator=(Ball_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ball_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ball_Info* internal_default_instance() {
    return reinterpret_cast<const Ball_Info*>(
               &_Ball_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ball_Info& a, Ball_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Ball_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ball_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ball_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ball_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ball_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ball_Info& from) {
    Ball_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ball_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Ball_Info";
  }
  protected:
  explicit Ball_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilteredXFieldNumber = 1,
    kFilteredYFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kDiffXFieldNumber = 6,
    kDiffYFieldNumber = 7,
    kSlopeRadianFieldNumber = 8,
    kInterceptFieldNumber = 9,
    kSpeedFieldNumber = 10,
    kSlopeFieldNumber = 11,
  };
  // required float filtered_x = 1;
  bool has_filtered_x() const;
  private:
  bool _internal_has_filtered_x() const;
  public:
  void clear_filtered_x();
  float filtered_x() const;
  void set_filtered_x(float value);
  private:
  float _internal_filtered_x() const;
  void _internal_set_filtered_x(float value);
  public:

  // required float filtered_y = 2;
  bool has_filtered_y() const;
  private:
  bool _internal_has_filtered_y() const;
  public:
  void clear_filtered_y();
  float filtered_y() const;
  void set_filtered_y(float value);
  private:
  float _internal_filtered_y() const;
  void _internal_set_filtered_y(float value);
  public:

  // required float x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float z = 5;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // required float diff_x = 6;
  bool has_diff_x() const;
  private:
  bool _internal_has_diff_x() const;
  public:
  void clear_diff_x();
  float diff_x() const;
  void set_diff_x(float value);
  private:
  float _internal_diff_x() const;
  void _internal_set_diff_x(float value);
  public:

  // required float diff_y = 7;
  bool has_diff_y() const;
  private:
  bool _internal_has_diff_y() const;
  public:
  void clear_diff_y();
  float diff_y() const;
  void set_diff_y(float value);
  private:
  float _internal_diff_y() const;
  void _internal_set_diff_y(float value);
  public:

  // required float slope_radian = 8;
  bool has_slope_radian() const;
  private:
  bool _internal_has_slope_radian() const;
  public:
  void clear_slope_radian();
  float slope_radian() const;
  void set_slope_radian(float value);
  private:
  float _internal_slope_radian() const;
  void _internal_set_slope_radian(float value);
  public:

  // required float intercept = 9;
  bool has_intercept() const;
  private:
  bool _internal_has_intercept() const;
  public:
  void clear_intercept();
  float intercept() const;
  void set_intercept(float value);
  private:
  float _internal_intercept() const;
  void _internal_set_intercept(float value);
  public:

  // required float speed = 10;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // required float slope = 11;
  bool has_slope() const;
  private:
  bool _internal_has_slope() const;
  public:
  void clear_slope();
  float slope() const;
  void set_slope(float value);
  private:
  float _internal_slope() const;
  void _internal_set_slope(float value);
  public:

  // @@protoc_insertion_point(class_scope:Ball_Info)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float filtered_x_;
    float filtered_y_;
    float x_;
    float y_;
    float z_;
    float diff_x_;
    float diff_y_;
    float slope_radian_;
    float intercept_;
    float speed_;
    float slope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_to_5fracoonai_2eproto;
};
// -------------------------------------------------------------------

class Geometry_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Geometry_Info) */ {
 public:
  inline Geometry_Info() : Geometry_Info(nullptr) {}
  ~Geometry_Info() override;
  explicit PROTOBUF_CONSTEXPR Geometry_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Geometry_Info(const Geometry_Info& from);
  Geometry_Info(Geometry_Info&& from) noexcept
    : Geometry_Info() {
    *this = ::std::move(from);
  }

  inline Geometry_Info& operator=(const Geometry_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geometry_Info& operator=(Geometry_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geometry_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geometry_Info* internal_default_instance() {
    return reinterpret_cast<const Geometry_Info*>(
               &_Geometry_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Geometry_Info& a, Geometry_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Geometry_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geometry_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geometry_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Geometry_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Geometry_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Geometry_Info& from) {
    Geometry_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geometry_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Geometry_Info";
  }
  protected:
  explicit Geometry_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldLengthFieldNumber = 1,
    kFieldWidthFieldNumber = 2,
    kGoalWidthFieldNumber = 3,
    kGoalDepthFieldNumber = 4,
    kBoundaryWidthFieldNumber = 5,
    kPenaltyAreaDepthFieldNumber = 6,
    kPenaltyAreaWidthFieldNumber = 7,
    kCenterCircleRadiusFieldNumber = 8,
    kLineThicknessFieldNumber = 9,
    kGoalCenterToPenaltyMarkFieldNumber = 10,
    kGoalHeightFieldNumber = 11,
    kBallRadiusFieldNumber = 12,
    kMaxRobotRadiusFieldNumber = 13,
    kGoalXFieldNumber = 14,
    kGoalYFieldNumber = 15,
  };
  // required int32 field_length = 1;
  bool has_field_length() const;
  private:
  bool _internal_has_field_length() const;
  public:
  void clear_field_length();
  int32_t field_length() const;
  void set_field_length(int32_t value);
  private:
  int32_t _internal_field_length() const;
  void _internal_set_field_length(int32_t value);
  public:

  // required int32 field_width = 2;
  bool has_field_width() const;
  private:
  bool _internal_has_field_width() const;
  public:
  void clear_field_width();
  int32_t field_width() const;
  void set_field_width(int32_t value);
  private:
  int32_t _internal_field_width() const;
  void _internal_set_field_width(int32_t value);
  public:

  // required int32 goal_width = 3;
  bool has_goal_width() const;
  private:
  bool _internal_has_goal_width() const;
  public:
  void clear_goal_width();
  int32_t goal_width() const;
  void set_goal_width(int32_t value);
  private:
  int32_t _internal_goal_width() const;
  void _internal_set_goal_width(int32_t value);
  public:

  // required int32 goal_depth = 4;
  bool has_goal_depth() const;
  private:
  bool _internal_has_goal_depth() const;
  public:
  void clear_goal_depth();
  int32_t goal_depth() const;
  void set_goal_depth(int32_t value);
  private:
  int32_t _internal_goal_depth() const;
  void _internal_set_goal_depth(int32_t value);
  public:

  // required int32 boundary_width = 5;
  bool has_boundary_width() const;
  private:
  bool _internal_has_boundary_width() const;
  public:
  void clear_boundary_width();
  int32_t boundary_width() const;
  void set_boundary_width(int32_t value);
  private:
  int32_t _internal_boundary_width() const;
  void _internal_set_boundary_width(int32_t value);
  public:

  // optional int32 penalty_area_depth = 6;
  bool has_penalty_area_depth() const;
  private:
  bool _internal_has_penalty_area_depth() const;
  public:
  void clear_penalty_area_depth();
  int32_t penalty_area_depth() const;
  void set_penalty_area_depth(int32_t value);
  private:
  int32_t _internal_penalty_area_depth() const;
  void _internal_set_penalty_area_depth(int32_t value);
  public:

  // optional int32 penalty_area_width = 7;
  bool has_penalty_area_width() const;
  private:
  bool _internal_has_penalty_area_width() const;
  public:
  void clear_penalty_area_width();
  int32_t penalty_area_width() const;
  void set_penalty_area_width(int32_t value);
  private:
  int32_t _internal_penalty_area_width() const;
  void _internal_set_penalty_area_width(int32_t value);
  public:

  // optional int32 center_circle_radius = 8;
  bool has_center_circle_radius() const;
  private:
  bool _internal_has_center_circle_radius() const;
  public:
  void clear_center_circle_radius();
  int32_t center_circle_radius() const;
  void set_center_circle_radius(int32_t value);
  private:
  int32_t _internal_center_circle_radius() const;
  void _internal_set_center_circle_radius(int32_t value);
  public:

  // optional int32 line_thickness = 9;
  bool has_line_thickness() const;
  private:
  bool _internal_has_line_thickness() const;
  public:
  void clear_line_thickness();
  int32_t line_thickness() const;
  void set_line_thickness(int32_t value);
  private:
  int32_t _internal_line_thickness() const;
  void _internal_set_line_thickness(int32_t value);
  public:

  // optional int32 goal_center_to_penalty_mark = 10;
  bool has_goal_center_to_penalty_mark() const;
  private:
  bool _internal_has_goal_center_to_penalty_mark() const;
  public:
  void clear_goal_center_to_penalty_mark();
  int32_t goal_center_to_penalty_mark() const;
  void set_goal_center_to_penalty_mark(int32_t value);
  private:
  int32_t _internal_goal_center_to_penalty_mark() const;
  void _internal_set_goal_center_to_penalty_mark(int32_t value);
  public:

  // optional int32 goal_height = 11;
  bool has_goal_height() const;
  private:
  bool _internal_has_goal_height() const;
  public:
  void clear_goal_height();
  int32_t goal_height() const;
  void set_goal_height(int32_t value);
  private:
  int32_t _internal_goal_height() const;
  void _internal_set_goal_height(int32_t value);
  public:

  // optional float ball_radius = 12;
  bool has_ball_radius() const;
  private:
  bool _internal_has_ball_radius() const;
  public:
  void clear_ball_radius();
  float ball_radius() const;
  void set_ball_radius(float value);
  private:
  float _internal_ball_radius() const;
  void _internal_set_ball_radius(float value);
  public:

  // optional float max_robot_radius = 13;
  bool has_max_robot_radius() const;
  private:
  bool _internal_has_max_robot_radius() const;
  public:
  void clear_max_robot_radius();
  float max_robot_radius() const;
  void set_max_robot_radius(float value);
  private:
  float _internal_max_robot_radius() const;
  void _internal_set_max_robot_radius(float value);
  public:

  // required float goal_x = 14;
  bool has_goal_x() const;
  private:
  bool _internal_has_goal_x() const;
  public:
  void clear_goal_x();
  float goal_x() const;
  void set_goal_x(float value);
  private:
  float _internal_goal_x() const;
  void _internal_set_goal_x(float value);
  public:

  // required float goal_y = 15;
  bool has_goal_y() const;
  private:
  bool _internal_has_goal_y() const;
  public:
  void clear_goal_y();
  float goal_y() const;
  void set_goal_y(float value);
  private:
  float _internal_goal_y() const;
  void _internal_set_goal_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:Geometry_Info)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t field_length_;
    int32_t field_width_;
    int32_t goal_width_;
    int32_t goal_depth_;
    int32_t boundary_width_;
    int32_t penalty_area_depth_;
    int32_t penalty_area_width_;
    int32_t center_circle_radius_;
    int32_t line_thickness_;
    int32_t goal_center_to_penalty_mark_;
    int32_t goal_height_;
    float ball_radius_;
    float max_robot_radius_;
    float goal_x_;
    float goal_y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_to_5fracoonai_2eproto;
};
// -------------------------------------------------------------------

class Referee_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Referee_Info) */ {
 public:
  inline Referee_Info() : Referee_Info(nullptr) {}
  ~Referee_Info() override;
  explicit PROTOBUF_CONSTEXPR Referee_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Referee_Info(const Referee_Info& from);
  Referee_Info(Referee_Info&& from) noexcept
    : Referee_Info() {
    *this = ::std::move(from);
  }

  inline Referee_Info& operator=(const Referee_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Referee_Info& operator=(Referee_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Referee_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Referee_Info* internal_default_instance() {
    return reinterpret_cast<const Referee_Info*>(
               &_Referee_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Referee_Info& a, Referee_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Referee_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Referee_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Referee_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Referee_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Referee_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Referee_Info& from) {
    Referee_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Referee_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Referee_Info";
  }
  protected:
  explicit Referee_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Referee_Info_Command Command;
  static constexpr Command HALT =
    Referee_Info_Command_HALT;
  static constexpr Command STOP =
    Referee_Info_Command_STOP;
  static constexpr Command NORMAL_START =
    Referee_Info_Command_NORMAL_START;
  static constexpr Command FORCE_START =
    Referee_Info_Command_FORCE_START;
  static constexpr Command PREPARE_KICKOFF_YELLOW =
    Referee_Info_Command_PREPARE_KICKOFF_YELLOW;
  static constexpr Command PREPARE_KICKOFF_BLUE =
    Referee_Info_Command_PREPARE_KICKOFF_BLUE;
  static constexpr Command PREPARE_PENALTY_YELLOW =
    Referee_Info_Command_PREPARE_PENALTY_YELLOW;
  static constexpr Command PREPARE_PENALTY_BLUE =
    Referee_Info_Command_PREPARE_PENALTY_BLUE;
  static constexpr Command DIRECT_FREE_YELLOW =
    Referee_Info_Command_DIRECT_FREE_YELLOW;
  static constexpr Command DIRECT_FREE_BLUE =
    Referee_Info_Command_DIRECT_FREE_BLUE;
  static constexpr Command INDIRECT_FREE_YELLOW =
    Referee_Info_Command_INDIRECT_FREE_YELLOW;
  static constexpr Command INDIRECT_FREE_BLUE =
    Referee_Info_Command_INDIRECT_FREE_BLUE;
  static constexpr Command TIMEOUT_YELLOW =
    Referee_Info_Command_TIMEOUT_YELLOW;
  static constexpr Command TIMEOUT_BLUE =
    Referee_Info_Command_TIMEOUT_BLUE;
  PROTOBUF_DEPRECATED_ENUM static constexpr Command GOAL_YELLOW =
    Referee_Info_Command_GOAL_YELLOW;
  PROTOBUF_DEPRECATED_ENUM static constexpr Command GOAL_BLUE =
    Referee_Info_Command_GOAL_BLUE;
  static constexpr Command BALL_PLACEMENT_YELLOW =
    Referee_Info_Command_BALL_PLACEMENT_YELLOW;
  static constexpr Command BALL_PLACEMENT_BLUE =
    Referee_Info_Command_BALL_PLACEMENT_BLUE;
  static inline bool Command_IsValid(int value) {
    return Referee_Info_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    Referee_Info_Command_Command_MIN;
  static constexpr Command Command_MAX =
    Referee_Info_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    Referee_Info_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return Referee_Info_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return Referee_Info_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return Referee_Info_Command_Parse(name, value);
  }

  typedef Referee_Info_Stage Stage;
  static constexpr Stage NORMAL_FIRST_HALF_PRE =
    Referee_Info_Stage_NORMAL_FIRST_HALF_PRE;
  static constexpr Stage NORMAL_FIRST_HALF =
    Referee_Info_Stage_NORMAL_FIRST_HALF;
  static constexpr Stage NORMAL_HALF_TIME =
    Referee_Info_Stage_NORMAL_HALF_TIME;
  static constexpr Stage NORMAL_SECOND_HALF_PRE =
    Referee_Info_Stage_NORMAL_SECOND_HALF_PRE;
  static constexpr Stage NORMAL_SECOND_HALF =
    Referee_Info_Stage_NORMAL_SECOND_HALF;
  static constexpr Stage EXTRA_TIME_BREAK =
    Referee_Info_Stage_EXTRA_TIME_BREAK;
  static constexpr Stage EXTRA_FIRST_HALF_PRE =
    Referee_Info_Stage_EXTRA_FIRST_HALF_PRE;
  static constexpr Stage EXTRA_FIRST_HALF =
    Referee_Info_Stage_EXTRA_FIRST_HALF;
  static constexpr Stage EXTRA_HALF_TIME =
    Referee_Info_Stage_EXTRA_HALF_TIME;
  static constexpr Stage EXTRA_SECOND_HALF_PRE =
    Referee_Info_Stage_EXTRA_SECOND_HALF_PRE;
  static constexpr Stage EXTRA_SECOND_HALF =
    Referee_Info_Stage_EXTRA_SECOND_HALF;
  static constexpr Stage PENALTY_SHOOTOUT_BREAK =
    Referee_Info_Stage_PENALTY_SHOOTOUT_BREAK;
  static constexpr Stage PENALTY_SHOOTOUT =
    Referee_Info_Stage_PENALTY_SHOOTOUT;
  static constexpr Stage POST_GAME =
    Referee_Info_Stage_POST_GAME;
  static inline bool Stage_IsValid(int value) {
    return Referee_Info_Stage_IsValid(value);
  }
  static constexpr Stage Stage_MIN =
    Referee_Info_Stage_Stage_MIN;
  static constexpr Stage Stage_MAX =
    Referee_Info_Stage_Stage_MAX;
  static constexpr int Stage_ARRAYSIZE =
    Referee_Info_Stage_Stage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Stage_descriptor() {
    return Referee_Info_Stage_descriptor();
  }
  template<typename T>
  static inline const std::string& Stage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Stage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Stage_Name.");
    return Referee_Info_Stage_Name(enum_t_value);
  }
  static inline bool Stage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Stage* value) {
    return Referee_Info_Stage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
    kStageFieldNumber = 2,
    kYellowCardsFieldNumber = 3,
    kRedCardsFieldNumber = 4,
    kPreCommandFieldNumber = 5,
    kNextCommandFieldNumber = 6,
    kBallPlacementXFieldNumber = 7,
    kBallPlacementYFieldNumber = 8,
  };
  // required .Referee_Info.Command command = 1;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  ::Referee_Info_Command command() const;
  void set_command(::Referee_Info_Command value);
  private:
  ::Referee_Info_Command _internal_command() const;
  void _internal_set_command(::Referee_Info_Command value);
  public:

  // required .Referee_Info.Stage stage = 2;
  bool has_stage() const;
  private:
  bool _internal_has_stage() const;
  public:
  void clear_stage();
  ::Referee_Info_Stage stage() const;
  void set_stage(::Referee_Info_Stage value);
  private:
  ::Referee_Info_Stage _internal_stage() const;
  void _internal_set_stage(::Referee_Info_Stage value);
  public:

  // required uint32 yellow_cards = 3;
  bool has_yellow_cards() const;
  private:
  bool _internal_has_yellow_cards() const;
  public:
  void clear_yellow_cards();
  uint32_t yellow_cards() const;
  void set_yellow_cards(uint32_t value);
  private:
  uint32_t _internal_yellow_cards() const;
  void _internal_set_yellow_cards(uint32_t value);
  public:

  // required uint32 red_cards = 4;
  bool has_red_cards() const;
  private:
  bool _internal_has_red_cards() const;
  public:
  void clear_red_cards();
  uint32_t red_cards() const;
  void set_red_cards(uint32_t value);
  private:
  uint32_t _internal_red_cards() const;
  void _internal_set_red_cards(uint32_t value);
  public:

  // optional .Referee_Info.Command pre_command = 5;
  bool has_pre_command() const;
  private:
  bool _internal_has_pre_command() const;
  public:
  void clear_pre_command();
  ::Referee_Info_Command pre_command() const;
  void set_pre_command(::Referee_Info_Command value);
  private:
  ::Referee_Info_Command _internal_pre_command() const;
  void _internal_set_pre_command(::Referee_Info_Command value);
  public:

  // optional .Referee_Info.Command next_command = 6;
  bool has_next_command() const;
  private:
  bool _internal_has_next_command() const;
  public:
  void clear_next_command();
  ::Referee_Info_Command next_command() const;
  void set_next_command(::Referee_Info_Command value);
  private:
  ::Referee_Info_Command _internal_next_command() const;
  void _internal_set_next_command(::Referee_Info_Command value);
  public:

  // optional float ball_placement_x = 7;
  bool has_ball_placement_x() const;
  private:
  bool _internal_has_ball_placement_x() const;
  public:
  void clear_ball_placement_x();
  float ball_placement_x() const;
  void set_ball_placement_x(float value);
  private:
  float _internal_ball_placement_x() const;
  void _internal_set_ball_placement_x(float value);
  public:

  // optional float ball_placement_y = 8;
  bool has_ball_placement_y() const;
  private:
  bool _internal_has_ball_placement_y() const;
  public:
  void clear_ball_placement_y();
  float ball_placement_y() const;
  void set_ball_placement_y(float value);
  private:
  float _internal_ball_placement_y() const;
  void _internal_set_ball_placement_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:Referee_Info)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int command_;
    int stage_;
    uint32_t yellow_cards_;
    uint32_t red_cards_;
    int pre_command_;
    int next_command_;
    float ball_placement_x_;
    float ball_placement_y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_to_5fracoonai_2eproto;
};
// -------------------------------------------------------------------

class RobotIP_Infos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotIP_Infos) */ {
 public:
  inline RobotIP_Infos() : RobotIP_Infos(nullptr) {}
  ~RobotIP_Infos() override;
  explicit PROTOBUF_CONSTEXPR RobotIP_Infos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotIP_Infos(const RobotIP_Infos& from);
  RobotIP_Infos(RobotIP_Infos&& from) noexcept
    : RobotIP_Infos() {
    *this = ::std::move(from);
  }

  inline RobotIP_Infos& operator=(const RobotIP_Infos& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotIP_Infos& operator=(RobotIP_Infos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotIP_Infos& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotIP_Infos* internal_default_instance() {
    return reinterpret_cast<const RobotIP_Infos*>(
               &_RobotIP_Infos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RobotIP_Infos& a, RobotIP_Infos& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotIP_Infos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotIP_Infos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotIP_Infos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotIP_Infos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotIP_Infos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotIP_Infos& from) {
    RobotIP_Infos::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotIP_Infos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotIP_Infos";
  }
  protected:
  explicit RobotIP_Infos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 2,
    kRobotIdFieldNumber = 1,
  };
  // required string ip = 2;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // required uint32 robot_id = 1;
  bool has_robot_id() const;
  private:
  bool _internal_has_robot_id() const;
  public:
  void clear_robot_id();
  uint32_t robot_id() const;
  void set_robot_id(uint32_t value);
  private:
  uint32_t _internal_robot_id() const;
  void _internal_set_robot_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RobotIP_Infos)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    uint32_t robot_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_to_5fracoonai_2eproto;
};
// -------------------------------------------------------------------

class Other_Infos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Other_Infos) */ {
 public:
  inline Other_Infos() : Other_Infos(nullptr) {}
  ~Other_Infos() override;
  explicit PROTOBUF_CONSTEXPR Other_Infos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Other_Infos(const Other_Infos& from);
  Other_Infos(Other_Infos&& from) noexcept
    : Other_Infos() {
    *this = ::std::move(from);
  }

  inline Other_Infos& operator=(const Other_Infos& from) {
    CopyFrom(from);
    return *this;
  }
  inline Other_Infos& operator=(Other_Infos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Other_Infos& default_instance() {
    return *internal_default_instance();
  }
  static inline const Other_Infos* internal_default_instance() {
    return reinterpret_cast<const Other_Infos*>(
               &_Other_Infos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Other_Infos& a, Other_Infos& b) {
    a.Swap(&b);
  }
  inline void Swap(Other_Infos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Other_Infos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Other_Infos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Other_Infos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Other_Infos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Other_Infos& from) {
    Other_Infos::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Other_Infos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Other_Infos";
  }
  protected:
  explicit Other_Infos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumOfCamerasFieldNumber = 1,
    kNumOfOurRobotsFieldNumber = 2,
    kNumOfEnemyRobotsFieldNumber = 3,
    kSecperframeFieldNumber = 4,
    kAttackDirectionFieldNumber = 6,
    kIsVisionRecvFieldNumber = 5,
    kIsBallMovingFieldNumber = 7,
  };
  // required int32 num_of_cameras = 1;
  bool has_num_of_cameras() const;
  private:
  bool _internal_has_num_of_cameras() const;
  public:
  void clear_num_of_cameras();
  int32_t num_of_cameras() const;
  void set_num_of_cameras(int32_t value);
  private:
  int32_t _internal_num_of_cameras() const;
  void _internal_set_num_of_cameras(int32_t value);
  public:

  // required int32 num_of_our_robots = 2;
  bool has_num_of_our_robots() const;
  private:
  bool _internal_has_num_of_our_robots() const;
  public:
  void clear_num_of_our_robots();
  int32_t num_of_our_robots() const;
  void set_num_of_our_robots(int32_t value);
  private:
  int32_t _internal_num_of_our_robots() const;
  void _internal_set_num_of_our_robots(int32_t value);
  public:

  // required int32 num_of_enemy_robots = 3;
  bool has_num_of_enemy_robots() const;
  private:
  bool _internal_has_num_of_enemy_robots() const;
  public:
  void clear_num_of_enemy_robots();
  int32_t num_of_enemy_robots() const;
  void set_num_of_enemy_robots(int32_t value);
  private:
  int32_t _internal_num_of_enemy_robots() const;
  void _internal_set_num_of_enemy_robots(int32_t value);
  public:

  // required float secperframe = 4;
  bool has_secperframe() const;
  private:
  bool _internal_has_secperframe() const;
  public:
  void clear_secperframe();
  float secperframe() const;
  void set_secperframe(float value);
  private:
  float _internal_secperframe() const;
  void _internal_set_secperframe(float value);
  public:

  // required int32 attack_direction = 6;
  bool has_attack_direction() const;
  private:
  bool _internal_has_attack_direction() const;
  public:
  void clear_attack_direction();
  int32_t attack_direction() const;
  void set_attack_direction(int32_t value);
  private:
  int32_t _internal_attack_direction() const;
  void _internal_set_attack_direction(int32_t value);
  public:

  // required bool is_vision_recv = 5;
  bool has_is_vision_recv() const;
  private:
  bool _internal_has_is_vision_recv() const;
  public:
  void clear_is_vision_recv();
  bool is_vision_recv() const;
  void set_is_vision_recv(bool value);
  private:
  bool _internal_is_vision_recv() const;
  void _internal_set_is_vision_recv(bool value);
  public:

  // required bool is_ball_moving = 7;
  bool has_is_ball_moving() const;
  private:
  bool _internal_has_is_ball_moving() const;
  public:
  void clear_is_ball_moving();
  bool is_ball_moving() const;
  void set_is_ball_moving(bool value);
  private:
  bool _internal_is_ball_moving() const;
  void _internal_set_is_ball_moving(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Other_Infos)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t num_of_cameras_;
    int32_t num_of_our_robots_;
    int32_t num_of_enemy_robots_;
    float secperframe_;
    int32_t attack_direction_;
    bool is_vision_recv_;
    bool is_ball_moving_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_to_5fracoonai_2eproto;
};
// -------------------------------------------------------------------

class RacoonMW_Packet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RacoonMW_Packet) */ {
 public:
  inline RacoonMW_Packet() : RacoonMW_Packet(nullptr) {}
  ~RacoonMW_Packet() override;
  explicit PROTOBUF_CONSTEXPR RacoonMW_Packet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RacoonMW_Packet(const RacoonMW_Packet& from);
  RacoonMW_Packet(RacoonMW_Packet&& from) noexcept
    : RacoonMW_Packet() {
    *this = ::std::move(from);
  }

  inline RacoonMW_Packet& operator=(const RacoonMW_Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline RacoonMW_Packet& operator=(RacoonMW_Packet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RacoonMW_Packet& default_instance() {
    return *internal_default_instance();
  }
  static inline const RacoonMW_Packet* internal_default_instance() {
    return reinterpret_cast<const RacoonMW_Packet*>(
               &_RacoonMW_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RacoonMW_Packet& a, RacoonMW_Packet& b) {
    a.Swap(&b);
  }
  inline void Swap(RacoonMW_Packet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RacoonMW_Packet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RacoonMW_Packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RacoonMW_Packet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RacoonMW_Packet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RacoonMW_Packet& from) {
    RacoonMW_Packet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RacoonMW_Packet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RacoonMW_Packet";
  }
  protected:
  explicit RacoonMW_Packet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOurRobotsFieldNumber = 1,
    kEnemyRobotsFieldNumber = 2,
    kRobotIpsFieldNumber = 6,
    kGeometryFieldNumber = 3,
    kBallFieldNumber = 4,
    kRefereeFieldNumber = 5,
    kInfoFieldNumber = 7,
  };
  // repeated .Robot_Infos our_robots = 1;
  int our_robots_size() const;
  private:
  int _internal_our_robots_size() const;
  public:
  void clear_our_robots();
  ::Robot_Infos* mutable_our_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >*
      mutable_our_robots();
  private:
  const ::Robot_Infos& _internal_our_robots(int index) const;
  ::Robot_Infos* _internal_add_our_robots();
  public:
  const ::Robot_Infos& our_robots(int index) const;
  ::Robot_Infos* add_our_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >&
      our_robots() const;

  // repeated .Robot_Infos enemy_robots = 2;
  int enemy_robots_size() const;
  private:
  int _internal_enemy_robots_size() const;
  public:
  void clear_enemy_robots();
  ::Robot_Infos* mutable_enemy_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >*
      mutable_enemy_robots();
  private:
  const ::Robot_Infos& _internal_enemy_robots(int index) const;
  ::Robot_Infos* _internal_add_enemy_robots();
  public:
  const ::Robot_Infos& enemy_robots(int index) const;
  ::Robot_Infos* add_enemy_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >&
      enemy_robots() const;

  // repeated .RobotIP_Infos robot_ips = 6;
  int robot_ips_size() const;
  private:
  int _internal_robot_ips_size() const;
  public:
  void clear_robot_ips();
  ::RobotIP_Infos* mutable_robot_ips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotIP_Infos >*
      mutable_robot_ips();
  private:
  const ::RobotIP_Infos& _internal_robot_ips(int index) const;
  ::RobotIP_Infos* _internal_add_robot_ips();
  public:
  const ::RobotIP_Infos& robot_ips(int index) const;
  ::RobotIP_Infos* add_robot_ips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotIP_Infos >&
      robot_ips() const;

  // required .Geometry_Info geometry = 3;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::Geometry_Info& geometry() const;
  PROTOBUF_NODISCARD ::Geometry_Info* release_geometry();
  ::Geometry_Info* mutable_geometry();
  void set_allocated_geometry(::Geometry_Info* geometry);
  private:
  const ::Geometry_Info& _internal_geometry() const;
  ::Geometry_Info* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::Geometry_Info* geometry);
  ::Geometry_Info* unsafe_arena_release_geometry();

  // required .Ball_Info ball = 4;
  bool has_ball() const;
  private:
  bool _internal_has_ball() const;
  public:
  void clear_ball();
  const ::Ball_Info& ball() const;
  PROTOBUF_NODISCARD ::Ball_Info* release_ball();
  ::Ball_Info* mutable_ball();
  void set_allocated_ball(::Ball_Info* ball);
  private:
  const ::Ball_Info& _internal_ball() const;
  ::Ball_Info* _internal_mutable_ball();
  public:
  void unsafe_arena_set_allocated_ball(
      ::Ball_Info* ball);
  ::Ball_Info* unsafe_arena_release_ball();

  // required .Referee_Info referee = 5;
  bool has_referee() const;
  private:
  bool _internal_has_referee() const;
  public:
  void clear_referee();
  const ::Referee_Info& referee() const;
  PROTOBUF_NODISCARD ::Referee_Info* release_referee();
  ::Referee_Info* mutable_referee();
  void set_allocated_referee(::Referee_Info* referee);
  private:
  const ::Referee_Info& _internal_referee() const;
  ::Referee_Info* _internal_mutable_referee();
  public:
  void unsafe_arena_set_allocated_referee(
      ::Referee_Info* referee);
  ::Referee_Info* unsafe_arena_release_referee();

  // required .Other_Infos info = 7;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Other_Infos& info() const;
  PROTOBUF_NODISCARD ::Other_Infos* release_info();
  ::Other_Infos* mutable_info();
  void set_allocated_info(::Other_Infos* info);
  private:
  const ::Other_Infos& _internal_info() const;
  ::Other_Infos* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Other_Infos* info);
  ::Other_Infos* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:RacoonMW_Packet)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos > our_robots_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos > enemy_robots_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotIP_Infos > robot_ips_;
    ::Geometry_Info* geometry_;
    ::Ball_Info* ball_;
    ::Referee_Info* referee_;
    ::Other_Infos* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_to_5fracoonai_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Robot_Infos

// required uint32 robot_id = 1;
inline bool Robot_Infos::_internal_has_robot_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Robot_Infos::has_robot_id() const {
  return _internal_has_robot_id();
}
inline void Robot_Infos::clear_robot_id() {
  _impl_.robot_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Robot_Infos::_internal_robot_id() const {
  return _impl_.robot_id_;
}
inline uint32_t Robot_Infos::robot_id() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.robot_id)
  return _internal_robot_id();
}
inline void Robot_Infos::_internal_set_robot_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.robot_id_ = value;
}
inline void Robot_Infos::set_robot_id(uint32_t value) {
  _internal_set_robot_id(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.robot_id)
}

// required float x = 2;
inline bool Robot_Infos::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Robot_Infos::has_x() const {
  return _internal_has_x();
}
inline void Robot_Infos::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Robot_Infos::_internal_x() const {
  return _impl_.x_;
}
inline float Robot_Infos::x() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.x)
  return _internal_x();
}
inline void Robot_Infos::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}
inline void Robot_Infos::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.x)
}

// required float y = 3;
inline bool Robot_Infos::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Robot_Infos::has_y() const {
  return _internal_has_y();
}
inline void Robot_Infos::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Robot_Infos::_internal_y() const {
  return _impl_.y_;
}
inline float Robot_Infos::y() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.y)
  return _internal_y();
}
inline void Robot_Infos::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}
inline void Robot_Infos::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.y)
}

// required float theta = 4;
inline bool Robot_Infos::_internal_has_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Robot_Infos::has_theta() const {
  return _internal_has_theta();
}
inline void Robot_Infos::clear_theta() {
  _impl_.theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Robot_Infos::_internal_theta() const {
  return _impl_.theta_;
}
inline float Robot_Infos::theta() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.theta)
  return _internal_theta();
}
inline void Robot_Infos::_internal_set_theta(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.theta_ = value;
}
inline void Robot_Infos::set_theta(float value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.theta)
}

// optional float distance_ball_robot = 5;
inline bool Robot_Infos::_internal_has_distance_ball_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Robot_Infos::has_distance_ball_robot() const {
  return _internal_has_distance_ball_robot();
}
inline void Robot_Infos::clear_distance_ball_robot() {
  _impl_.distance_ball_robot_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Robot_Infos::_internal_distance_ball_robot() const {
  return _impl_.distance_ball_robot_;
}
inline float Robot_Infos::distance_ball_robot() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.distance_ball_robot)
  return _internal_distance_ball_robot();
}
inline void Robot_Infos::_internal_set_distance_ball_robot(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.distance_ball_robot_ = value;
}
inline void Robot_Infos::set_distance_ball_robot(float value) {
  _internal_set_distance_ball_robot(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.distance_ball_robot)
}

// optional float radian_ball_robot = 6;
inline bool Robot_Infos::_internal_has_radian_ball_robot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Robot_Infos::has_radian_ball_robot() const {
  return _internal_has_radian_ball_robot();
}
inline void Robot_Infos::clear_radian_ball_robot() {
  _impl_.radian_ball_robot_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Robot_Infos::_internal_radian_ball_robot() const {
  return _impl_.radian_ball_robot_;
}
inline float Robot_Infos::radian_ball_robot() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.radian_ball_robot)
  return _internal_radian_ball_robot();
}
inline void Robot_Infos::_internal_set_radian_ball_robot(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.radian_ball_robot_ = value;
}
inline void Robot_Infos::set_radian_ball_robot(float value) {
  _internal_set_radian_ball_robot(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.radian_ball_robot)
}

// required float diff_x = 7;
inline bool Robot_Infos::_internal_has_diff_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Robot_Infos::has_diff_x() const {
  return _internal_has_diff_x();
}
inline void Robot_Infos::clear_diff_x() {
  _impl_.diff_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Robot_Infos::_internal_diff_x() const {
  return _impl_.diff_x_;
}
inline float Robot_Infos::diff_x() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.diff_x)
  return _internal_diff_x();
}
inline void Robot_Infos::_internal_set_diff_x(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.diff_x_ = value;
}
inline void Robot_Infos::set_diff_x(float value) {
  _internal_set_diff_x(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.diff_x)
}

// required float diff_y = 8;
inline bool Robot_Infos::_internal_has_diff_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Robot_Infos::has_diff_y() const {
  return _internal_has_diff_y();
}
inline void Robot_Infos::clear_diff_y() {
  _impl_.diff_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Robot_Infos::_internal_diff_y() const {
  return _impl_.diff_y_;
}
inline float Robot_Infos::diff_y() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.diff_y)
  return _internal_diff_y();
}
inline void Robot_Infos::_internal_set_diff_y(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.diff_y_ = value;
}
inline void Robot_Infos::set_diff_y(float value) {
  _internal_set_diff_y(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.diff_y)
}

// required float diff_theta = 9;
inline bool Robot_Infos::_internal_has_diff_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Robot_Infos::has_diff_theta() const {
  return _internal_has_diff_theta();
}
inline void Robot_Infos::clear_diff_theta() {
  _impl_.diff_theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Robot_Infos::_internal_diff_theta() const {
  return _impl_.diff_theta_;
}
inline float Robot_Infos::diff_theta() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.diff_theta)
  return _internal_diff_theta();
}
inline void Robot_Infos::_internal_set_diff_theta(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.diff_theta_ = value;
}
inline void Robot_Infos::set_diff_theta(float value) {
  _internal_set_diff_theta(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.diff_theta)
}

// required float speed = 10;
inline bool Robot_Infos::_internal_has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Robot_Infos::has_speed() const {
  return _internal_has_speed();
}
inline void Robot_Infos::clear_speed() {
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float Robot_Infos::_internal_speed() const {
  return _impl_.speed_;
}
inline float Robot_Infos::speed() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.speed)
  return _internal_speed();
}
inline void Robot_Infos::_internal_set_speed(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.speed_ = value;
}
inline void Robot_Infos::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.speed)
}

// required float slope = 11;
inline bool Robot_Infos::_internal_has_slope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Robot_Infos::has_slope() const {
  return _internal_has_slope();
}
inline void Robot_Infos::clear_slope() {
  _impl_.slope_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float Robot_Infos::_internal_slope() const {
  return _impl_.slope_;
}
inline float Robot_Infos::slope() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.slope)
  return _internal_slope();
}
inline void Robot_Infos::_internal_set_slope(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.slope_ = value;
}
inline void Robot_Infos::set_slope(float value) {
  _internal_set_slope(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.slope)
}

// required float intercept = 12;
inline bool Robot_Infos::_internal_has_intercept() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Robot_Infos::has_intercept() const {
  return _internal_has_intercept();
}
inline void Robot_Infos::clear_intercept() {
  _impl_.intercept_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float Robot_Infos::_internal_intercept() const {
  return _impl_.intercept_;
}
inline float Robot_Infos::intercept() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.intercept)
  return _internal_intercept();
}
inline void Robot_Infos::_internal_set_intercept(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.intercept_ = value;
}
inline void Robot_Infos::set_intercept(float value) {
  _internal_set_intercept(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.intercept)
}

// required float angular_velocity = 13;
inline bool Robot_Infos::_internal_has_angular_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Robot_Infos::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void Robot_Infos::clear_angular_velocity() {
  _impl_.angular_velocity_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float Robot_Infos::_internal_angular_velocity() const {
  return _impl_.angular_velocity_;
}
inline float Robot_Infos::angular_velocity() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.angular_velocity)
  return _internal_angular_velocity();
}
inline void Robot_Infos::_internal_set_angular_velocity(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.angular_velocity_ = value;
}
inline void Robot_Infos::set_angular_velocity(float value) {
  _internal_set_angular_velocity(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.angular_velocity)
}

// required bool visible = 14;
inline bool Robot_Infos::_internal_has_visible() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Robot_Infos::has_visible() const {
  return _internal_has_visible();
}
inline void Robot_Infos::clear_visible() {
  _impl_.visible_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool Robot_Infos::_internal_visible() const {
  return _impl_.visible_;
}
inline bool Robot_Infos::visible() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.visible)
  return _internal_visible();
}
inline void Robot_Infos::_internal_set_visible(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.visible_ = value;
}
inline void Robot_Infos::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.visible)
}

// optional bool ball_catch = 15;
inline bool Robot_Infos::_internal_has_ball_catch() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Robot_Infos::has_ball_catch() const {
  return _internal_has_ball_catch();
}
inline void Robot_Infos::clear_ball_catch() {
  _impl_.ball_catch_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Robot_Infos::_internal_ball_catch() const {
  return _impl_.ball_catch_;
}
inline bool Robot_Infos::ball_catch() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.ball_catch)
  return _internal_ball_catch();
}
inline void Robot_Infos::_internal_set_ball_catch(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.ball_catch_ = value;
}
inline void Robot_Infos::set_ball_catch(bool value) {
  _internal_set_ball_catch(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.ball_catch)
}

// optional bool online = 16;
inline bool Robot_Infos::_internal_has_online() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Robot_Infos::has_online() const {
  return _internal_has_online();
}
inline void Robot_Infos::clear_online() {
  _impl_.online_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool Robot_Infos::_internal_online() const {
  return _impl_.online_;
}
inline bool Robot_Infos::online() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.online)
  return _internal_online();
}
inline void Robot_Infos::_internal_set_online(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.online_ = value;
}
inline void Robot_Infos::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.online)
}

// optional float battery_voltage = 17;
inline bool Robot_Infos::_internal_has_battery_voltage() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Robot_Infos::has_battery_voltage() const {
  return _internal_has_battery_voltage();
}
inline void Robot_Infos::clear_battery_voltage() {
  _impl_.battery_voltage_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float Robot_Infos::_internal_battery_voltage() const {
  return _impl_.battery_voltage_;
}
inline float Robot_Infos::battery_voltage() const {
  // @@protoc_insertion_point(field_get:Robot_Infos.battery_voltage)
  return _internal_battery_voltage();
}
inline void Robot_Infos::_internal_set_battery_voltage(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.battery_voltage_ = value;
}
inline void Robot_Infos::set_battery_voltage(float value) {
  _internal_set_battery_voltage(value);
  // @@protoc_insertion_point(field_set:Robot_Infos.battery_voltage)
}

// -------------------------------------------------------------------

// Ball_Info

// required float filtered_x = 1;
inline bool Ball_Info::_internal_has_filtered_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ball_Info::has_filtered_x() const {
  return _internal_has_filtered_x();
}
inline void Ball_Info::clear_filtered_x() {
  _impl_.filtered_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Ball_Info::_internal_filtered_x() const {
  return _impl_.filtered_x_;
}
inline float Ball_Info::filtered_x() const {
  // @@protoc_insertion_point(field_get:Ball_Info.filtered_x)
  return _internal_filtered_x();
}
inline void Ball_Info::_internal_set_filtered_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filtered_x_ = value;
}
inline void Ball_Info::set_filtered_x(float value) {
  _internal_set_filtered_x(value);
  // @@protoc_insertion_point(field_set:Ball_Info.filtered_x)
}

// required float filtered_y = 2;
inline bool Ball_Info::_internal_has_filtered_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ball_Info::has_filtered_y() const {
  return _internal_has_filtered_y();
}
inline void Ball_Info::clear_filtered_y() {
  _impl_.filtered_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Ball_Info::_internal_filtered_y() const {
  return _impl_.filtered_y_;
}
inline float Ball_Info::filtered_y() const {
  // @@protoc_insertion_point(field_get:Ball_Info.filtered_y)
  return _internal_filtered_y();
}
inline void Ball_Info::_internal_set_filtered_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filtered_y_ = value;
}
inline void Ball_Info::set_filtered_y(float value) {
  _internal_set_filtered_y(value);
  // @@protoc_insertion_point(field_set:Ball_Info.filtered_y)
}

// required float x = 3;
inline bool Ball_Info::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Ball_Info::has_x() const {
  return _internal_has_x();
}
inline void Ball_Info::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Ball_Info::_internal_x() const {
  return _impl_.x_;
}
inline float Ball_Info::x() const {
  // @@protoc_insertion_point(field_get:Ball_Info.x)
  return _internal_x();
}
inline void Ball_Info::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.x_ = value;
}
inline void Ball_Info::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Ball_Info.x)
}

// required float y = 4;
inline bool Ball_Info::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Ball_Info::has_y() const {
  return _internal_has_y();
}
inline void Ball_Info::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Ball_Info::_internal_y() const {
  return _impl_.y_;
}
inline float Ball_Info::y() const {
  // @@protoc_insertion_point(field_get:Ball_Info.y)
  return _internal_y();
}
inline void Ball_Info::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.y_ = value;
}
inline void Ball_Info::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Ball_Info.y)
}

// required float z = 5;
inline bool Ball_Info::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Ball_Info::has_z() const {
  return _internal_has_z();
}
inline void Ball_Info::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Ball_Info::_internal_z() const {
  return _impl_.z_;
}
inline float Ball_Info::z() const {
  // @@protoc_insertion_point(field_get:Ball_Info.z)
  return _internal_z();
}
inline void Ball_Info::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.z_ = value;
}
inline void Ball_Info::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Ball_Info.z)
}

// required float diff_x = 6;
inline bool Ball_Info::_internal_has_diff_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Ball_Info::has_diff_x() const {
  return _internal_has_diff_x();
}
inline void Ball_Info::clear_diff_x() {
  _impl_.diff_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Ball_Info::_internal_diff_x() const {
  return _impl_.diff_x_;
}
inline float Ball_Info::diff_x() const {
  // @@protoc_insertion_point(field_get:Ball_Info.diff_x)
  return _internal_diff_x();
}
inline void Ball_Info::_internal_set_diff_x(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.diff_x_ = value;
}
inline void Ball_Info::set_diff_x(float value) {
  _internal_set_diff_x(value);
  // @@protoc_insertion_point(field_set:Ball_Info.diff_x)
}

// required float diff_y = 7;
inline bool Ball_Info::_internal_has_diff_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Ball_Info::has_diff_y() const {
  return _internal_has_diff_y();
}
inline void Ball_Info::clear_diff_y() {
  _impl_.diff_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Ball_Info::_internal_diff_y() const {
  return _impl_.diff_y_;
}
inline float Ball_Info::diff_y() const {
  // @@protoc_insertion_point(field_get:Ball_Info.diff_y)
  return _internal_diff_y();
}
inline void Ball_Info::_internal_set_diff_y(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.diff_y_ = value;
}
inline void Ball_Info::set_diff_y(float value) {
  _internal_set_diff_y(value);
  // @@protoc_insertion_point(field_set:Ball_Info.diff_y)
}

// required float slope_radian = 8;
inline bool Ball_Info::_internal_has_slope_radian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Ball_Info::has_slope_radian() const {
  return _internal_has_slope_radian();
}
inline void Ball_Info::clear_slope_radian() {
  _impl_.slope_radian_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Ball_Info::_internal_slope_radian() const {
  return _impl_.slope_radian_;
}
inline float Ball_Info::slope_radian() const {
  // @@protoc_insertion_point(field_get:Ball_Info.slope_radian)
  return _internal_slope_radian();
}
inline void Ball_Info::_internal_set_slope_radian(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.slope_radian_ = value;
}
inline void Ball_Info::set_slope_radian(float value) {
  _internal_set_slope_radian(value);
  // @@protoc_insertion_point(field_set:Ball_Info.slope_radian)
}

// required float intercept = 9;
inline bool Ball_Info::_internal_has_intercept() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Ball_Info::has_intercept() const {
  return _internal_has_intercept();
}
inline void Ball_Info::clear_intercept() {
  _impl_.intercept_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Ball_Info::_internal_intercept() const {
  return _impl_.intercept_;
}
inline float Ball_Info::intercept() const {
  // @@protoc_insertion_point(field_get:Ball_Info.intercept)
  return _internal_intercept();
}
inline void Ball_Info::_internal_set_intercept(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.intercept_ = value;
}
inline void Ball_Info::set_intercept(float value) {
  _internal_set_intercept(value);
  // @@protoc_insertion_point(field_set:Ball_Info.intercept)
}

// required float speed = 10;
inline bool Ball_Info::_internal_has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Ball_Info::has_speed() const {
  return _internal_has_speed();
}
inline void Ball_Info::clear_speed() {
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float Ball_Info::_internal_speed() const {
  return _impl_.speed_;
}
inline float Ball_Info::speed() const {
  // @@protoc_insertion_point(field_get:Ball_Info.speed)
  return _internal_speed();
}
inline void Ball_Info::_internal_set_speed(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.speed_ = value;
}
inline void Ball_Info::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Ball_Info.speed)
}

// required float slope = 11;
inline bool Ball_Info::_internal_has_slope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Ball_Info::has_slope() const {
  return _internal_has_slope();
}
inline void Ball_Info::clear_slope() {
  _impl_.slope_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float Ball_Info::_internal_slope() const {
  return _impl_.slope_;
}
inline float Ball_Info::slope() const {
  // @@protoc_insertion_point(field_get:Ball_Info.slope)
  return _internal_slope();
}
inline void Ball_Info::_internal_set_slope(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.slope_ = value;
}
inline void Ball_Info::set_slope(float value) {
  _internal_set_slope(value);
  // @@protoc_insertion_point(field_set:Ball_Info.slope)
}

// -------------------------------------------------------------------

// Geometry_Info

// required int32 field_length = 1;
inline bool Geometry_Info::_internal_has_field_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Geometry_Info::has_field_length() const {
  return _internal_has_field_length();
}
inline void Geometry_Info::clear_field_length() {
  _impl_.field_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Geometry_Info::_internal_field_length() const {
  return _impl_.field_length_;
}
inline int32_t Geometry_Info::field_length() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.field_length)
  return _internal_field_length();
}
inline void Geometry_Info::_internal_set_field_length(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.field_length_ = value;
}
inline void Geometry_Info::set_field_length(int32_t value) {
  _internal_set_field_length(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.field_length)
}

// required int32 field_width = 2;
inline bool Geometry_Info::_internal_has_field_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Geometry_Info::has_field_width() const {
  return _internal_has_field_width();
}
inline void Geometry_Info::clear_field_width() {
  _impl_.field_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Geometry_Info::_internal_field_width() const {
  return _impl_.field_width_;
}
inline int32_t Geometry_Info::field_width() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.field_width)
  return _internal_field_width();
}
inline void Geometry_Info::_internal_set_field_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.field_width_ = value;
}
inline void Geometry_Info::set_field_width(int32_t value) {
  _internal_set_field_width(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.field_width)
}

// required int32 goal_width = 3;
inline bool Geometry_Info::_internal_has_goal_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Geometry_Info::has_goal_width() const {
  return _internal_has_goal_width();
}
inline void Geometry_Info::clear_goal_width() {
  _impl_.goal_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Geometry_Info::_internal_goal_width() const {
  return _impl_.goal_width_;
}
inline int32_t Geometry_Info::goal_width() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.goal_width)
  return _internal_goal_width();
}
inline void Geometry_Info::_internal_set_goal_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.goal_width_ = value;
}
inline void Geometry_Info::set_goal_width(int32_t value) {
  _internal_set_goal_width(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.goal_width)
}

// required int32 goal_depth = 4;
inline bool Geometry_Info::_internal_has_goal_depth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Geometry_Info::has_goal_depth() const {
  return _internal_has_goal_depth();
}
inline void Geometry_Info::clear_goal_depth() {
  _impl_.goal_depth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Geometry_Info::_internal_goal_depth() const {
  return _impl_.goal_depth_;
}
inline int32_t Geometry_Info::goal_depth() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.goal_depth)
  return _internal_goal_depth();
}
inline void Geometry_Info::_internal_set_goal_depth(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.goal_depth_ = value;
}
inline void Geometry_Info::set_goal_depth(int32_t value) {
  _internal_set_goal_depth(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.goal_depth)
}

// required int32 boundary_width = 5;
inline bool Geometry_Info::_internal_has_boundary_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Geometry_Info::has_boundary_width() const {
  return _internal_has_boundary_width();
}
inline void Geometry_Info::clear_boundary_width() {
  _impl_.boundary_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Geometry_Info::_internal_boundary_width() const {
  return _impl_.boundary_width_;
}
inline int32_t Geometry_Info::boundary_width() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.boundary_width)
  return _internal_boundary_width();
}
inline void Geometry_Info::_internal_set_boundary_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.boundary_width_ = value;
}
inline void Geometry_Info::set_boundary_width(int32_t value) {
  _internal_set_boundary_width(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.boundary_width)
}

// optional int32 penalty_area_depth = 6;
inline bool Geometry_Info::_internal_has_penalty_area_depth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Geometry_Info::has_penalty_area_depth() const {
  return _internal_has_penalty_area_depth();
}
inline void Geometry_Info::clear_penalty_area_depth() {
  _impl_.penalty_area_depth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t Geometry_Info::_internal_penalty_area_depth() const {
  return _impl_.penalty_area_depth_;
}
inline int32_t Geometry_Info::penalty_area_depth() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.penalty_area_depth)
  return _internal_penalty_area_depth();
}
inline void Geometry_Info::_internal_set_penalty_area_depth(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.penalty_area_depth_ = value;
}
inline void Geometry_Info::set_penalty_area_depth(int32_t value) {
  _internal_set_penalty_area_depth(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.penalty_area_depth)
}

// optional int32 penalty_area_width = 7;
inline bool Geometry_Info::_internal_has_penalty_area_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Geometry_Info::has_penalty_area_width() const {
  return _internal_has_penalty_area_width();
}
inline void Geometry_Info::clear_penalty_area_width() {
  _impl_.penalty_area_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t Geometry_Info::_internal_penalty_area_width() const {
  return _impl_.penalty_area_width_;
}
inline int32_t Geometry_Info::penalty_area_width() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.penalty_area_width)
  return _internal_penalty_area_width();
}
inline void Geometry_Info::_internal_set_penalty_area_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.penalty_area_width_ = value;
}
inline void Geometry_Info::set_penalty_area_width(int32_t value) {
  _internal_set_penalty_area_width(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.penalty_area_width)
}

// optional int32 center_circle_radius = 8;
inline bool Geometry_Info::_internal_has_center_circle_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Geometry_Info::has_center_circle_radius() const {
  return _internal_has_center_circle_radius();
}
inline void Geometry_Info::clear_center_circle_radius() {
  _impl_.center_circle_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t Geometry_Info::_internal_center_circle_radius() const {
  return _impl_.center_circle_radius_;
}
inline int32_t Geometry_Info::center_circle_radius() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.center_circle_radius)
  return _internal_center_circle_radius();
}
inline void Geometry_Info::_internal_set_center_circle_radius(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.center_circle_radius_ = value;
}
inline void Geometry_Info::set_center_circle_radius(int32_t value) {
  _internal_set_center_circle_radius(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.center_circle_radius)
}

// optional int32 line_thickness = 9;
inline bool Geometry_Info::_internal_has_line_thickness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Geometry_Info::has_line_thickness() const {
  return _internal_has_line_thickness();
}
inline void Geometry_Info::clear_line_thickness() {
  _impl_.line_thickness_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t Geometry_Info::_internal_line_thickness() const {
  return _impl_.line_thickness_;
}
inline int32_t Geometry_Info::line_thickness() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.line_thickness)
  return _internal_line_thickness();
}
inline void Geometry_Info::_internal_set_line_thickness(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.line_thickness_ = value;
}
inline void Geometry_Info::set_line_thickness(int32_t value) {
  _internal_set_line_thickness(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.line_thickness)
}

// optional int32 goal_center_to_penalty_mark = 10;
inline bool Geometry_Info::_internal_has_goal_center_to_penalty_mark() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Geometry_Info::has_goal_center_to_penalty_mark() const {
  return _internal_has_goal_center_to_penalty_mark();
}
inline void Geometry_Info::clear_goal_center_to_penalty_mark() {
  _impl_.goal_center_to_penalty_mark_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t Geometry_Info::_internal_goal_center_to_penalty_mark() const {
  return _impl_.goal_center_to_penalty_mark_;
}
inline int32_t Geometry_Info::goal_center_to_penalty_mark() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.goal_center_to_penalty_mark)
  return _internal_goal_center_to_penalty_mark();
}
inline void Geometry_Info::_internal_set_goal_center_to_penalty_mark(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.goal_center_to_penalty_mark_ = value;
}
inline void Geometry_Info::set_goal_center_to_penalty_mark(int32_t value) {
  _internal_set_goal_center_to_penalty_mark(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.goal_center_to_penalty_mark)
}

// optional int32 goal_height = 11;
inline bool Geometry_Info::_internal_has_goal_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Geometry_Info::has_goal_height() const {
  return _internal_has_goal_height();
}
inline void Geometry_Info::clear_goal_height() {
  _impl_.goal_height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t Geometry_Info::_internal_goal_height() const {
  return _impl_.goal_height_;
}
inline int32_t Geometry_Info::goal_height() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.goal_height)
  return _internal_goal_height();
}
inline void Geometry_Info::_internal_set_goal_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.goal_height_ = value;
}
inline void Geometry_Info::set_goal_height(int32_t value) {
  _internal_set_goal_height(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.goal_height)
}

// optional float ball_radius = 12;
inline bool Geometry_Info::_internal_has_ball_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Geometry_Info::has_ball_radius() const {
  return _internal_has_ball_radius();
}
inline void Geometry_Info::clear_ball_radius() {
  _impl_.ball_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float Geometry_Info::_internal_ball_radius() const {
  return _impl_.ball_radius_;
}
inline float Geometry_Info::ball_radius() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.ball_radius)
  return _internal_ball_radius();
}
inline void Geometry_Info::_internal_set_ball_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.ball_radius_ = value;
}
inline void Geometry_Info::set_ball_radius(float value) {
  _internal_set_ball_radius(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.ball_radius)
}

// optional float max_robot_radius = 13;
inline bool Geometry_Info::_internal_has_max_robot_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Geometry_Info::has_max_robot_radius() const {
  return _internal_has_max_robot_radius();
}
inline void Geometry_Info::clear_max_robot_radius() {
  _impl_.max_robot_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float Geometry_Info::_internal_max_robot_radius() const {
  return _impl_.max_robot_radius_;
}
inline float Geometry_Info::max_robot_radius() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.max_robot_radius)
  return _internal_max_robot_radius();
}
inline void Geometry_Info::_internal_set_max_robot_radius(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.max_robot_radius_ = value;
}
inline void Geometry_Info::set_max_robot_radius(float value) {
  _internal_set_max_robot_radius(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.max_robot_radius)
}

// required float goal_x = 14;
inline bool Geometry_Info::_internal_has_goal_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Geometry_Info::has_goal_x() const {
  return _internal_has_goal_x();
}
inline void Geometry_Info::clear_goal_x() {
  _impl_.goal_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float Geometry_Info::_internal_goal_x() const {
  return _impl_.goal_x_;
}
inline float Geometry_Info::goal_x() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.goal_x)
  return _internal_goal_x();
}
inline void Geometry_Info::_internal_set_goal_x(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.goal_x_ = value;
}
inline void Geometry_Info::set_goal_x(float value) {
  _internal_set_goal_x(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.goal_x)
}

// required float goal_y = 15;
inline bool Geometry_Info::_internal_has_goal_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Geometry_Info::has_goal_y() const {
  return _internal_has_goal_y();
}
inline void Geometry_Info::clear_goal_y() {
  _impl_.goal_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float Geometry_Info::_internal_goal_y() const {
  return _impl_.goal_y_;
}
inline float Geometry_Info::goal_y() const {
  // @@protoc_insertion_point(field_get:Geometry_Info.goal_y)
  return _internal_goal_y();
}
inline void Geometry_Info::_internal_set_goal_y(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.goal_y_ = value;
}
inline void Geometry_Info::set_goal_y(float value) {
  _internal_set_goal_y(value);
  // @@protoc_insertion_point(field_set:Geometry_Info.goal_y)
}

// -------------------------------------------------------------------

// Referee_Info

// required .Referee_Info.Command command = 1;
inline bool Referee_Info::_internal_has_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Referee_Info::has_command() const {
  return _internal_has_command();
}
inline void Referee_Info::clear_command() {
  _impl_.command_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Referee_Info_Command Referee_Info::_internal_command() const {
  return static_cast< ::Referee_Info_Command >(_impl_.command_);
}
inline ::Referee_Info_Command Referee_Info::command() const {
  // @@protoc_insertion_point(field_get:Referee_Info.command)
  return _internal_command();
}
inline void Referee_Info::_internal_set_command(::Referee_Info_Command value) {
  assert(::Referee_Info_Command_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.command_ = value;
}
inline void Referee_Info::set_command(::Referee_Info_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:Referee_Info.command)
}

// required .Referee_Info.Stage stage = 2;
inline bool Referee_Info::_internal_has_stage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Referee_Info::has_stage() const {
  return _internal_has_stage();
}
inline void Referee_Info::clear_stage() {
  _impl_.stage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Referee_Info_Stage Referee_Info::_internal_stage() const {
  return static_cast< ::Referee_Info_Stage >(_impl_.stage_);
}
inline ::Referee_Info_Stage Referee_Info::stage() const {
  // @@protoc_insertion_point(field_get:Referee_Info.stage)
  return _internal_stage();
}
inline void Referee_Info::_internal_set_stage(::Referee_Info_Stage value) {
  assert(::Referee_Info_Stage_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stage_ = value;
}
inline void Referee_Info::set_stage(::Referee_Info_Stage value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:Referee_Info.stage)
}

// required uint32 yellow_cards = 3;
inline bool Referee_Info::_internal_has_yellow_cards() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Referee_Info::has_yellow_cards() const {
  return _internal_has_yellow_cards();
}
inline void Referee_Info::clear_yellow_cards() {
  _impl_.yellow_cards_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Referee_Info::_internal_yellow_cards() const {
  return _impl_.yellow_cards_;
}
inline uint32_t Referee_Info::yellow_cards() const {
  // @@protoc_insertion_point(field_get:Referee_Info.yellow_cards)
  return _internal_yellow_cards();
}
inline void Referee_Info::_internal_set_yellow_cards(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.yellow_cards_ = value;
}
inline void Referee_Info::set_yellow_cards(uint32_t value) {
  _internal_set_yellow_cards(value);
  // @@protoc_insertion_point(field_set:Referee_Info.yellow_cards)
}

// required uint32 red_cards = 4;
inline bool Referee_Info::_internal_has_red_cards() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Referee_Info::has_red_cards() const {
  return _internal_has_red_cards();
}
inline void Referee_Info::clear_red_cards() {
  _impl_.red_cards_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Referee_Info::_internal_red_cards() const {
  return _impl_.red_cards_;
}
inline uint32_t Referee_Info::red_cards() const {
  // @@protoc_insertion_point(field_get:Referee_Info.red_cards)
  return _internal_red_cards();
}
inline void Referee_Info::_internal_set_red_cards(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.red_cards_ = value;
}
inline void Referee_Info::set_red_cards(uint32_t value) {
  _internal_set_red_cards(value);
  // @@protoc_insertion_point(field_set:Referee_Info.red_cards)
}

// optional .Referee_Info.Command pre_command = 5;
inline bool Referee_Info::_internal_has_pre_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Referee_Info::has_pre_command() const {
  return _internal_has_pre_command();
}
inline void Referee_Info::clear_pre_command() {
  _impl_.pre_command_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Referee_Info_Command Referee_Info::_internal_pre_command() const {
  return static_cast< ::Referee_Info_Command >(_impl_.pre_command_);
}
inline ::Referee_Info_Command Referee_Info::pre_command() const {
  // @@protoc_insertion_point(field_get:Referee_Info.pre_command)
  return _internal_pre_command();
}
inline void Referee_Info::_internal_set_pre_command(::Referee_Info_Command value) {
  assert(::Referee_Info_Command_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pre_command_ = value;
}
inline void Referee_Info::set_pre_command(::Referee_Info_Command value) {
  _internal_set_pre_command(value);
  // @@protoc_insertion_point(field_set:Referee_Info.pre_command)
}

// optional .Referee_Info.Command next_command = 6;
inline bool Referee_Info::_internal_has_next_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Referee_Info::has_next_command() const {
  return _internal_has_next_command();
}
inline void Referee_Info::clear_next_command() {
  _impl_.next_command_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::Referee_Info_Command Referee_Info::_internal_next_command() const {
  return static_cast< ::Referee_Info_Command >(_impl_.next_command_);
}
inline ::Referee_Info_Command Referee_Info::next_command() const {
  // @@protoc_insertion_point(field_get:Referee_Info.next_command)
  return _internal_next_command();
}
inline void Referee_Info::_internal_set_next_command(::Referee_Info_Command value) {
  assert(::Referee_Info_Command_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.next_command_ = value;
}
inline void Referee_Info::set_next_command(::Referee_Info_Command value) {
  _internal_set_next_command(value);
  // @@protoc_insertion_point(field_set:Referee_Info.next_command)
}

// optional float ball_placement_x = 7;
inline bool Referee_Info::_internal_has_ball_placement_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Referee_Info::has_ball_placement_x() const {
  return _internal_has_ball_placement_x();
}
inline void Referee_Info::clear_ball_placement_x() {
  _impl_.ball_placement_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Referee_Info::_internal_ball_placement_x() const {
  return _impl_.ball_placement_x_;
}
inline float Referee_Info::ball_placement_x() const {
  // @@protoc_insertion_point(field_get:Referee_Info.ball_placement_x)
  return _internal_ball_placement_x();
}
inline void Referee_Info::_internal_set_ball_placement_x(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ball_placement_x_ = value;
}
inline void Referee_Info::set_ball_placement_x(float value) {
  _internal_set_ball_placement_x(value);
  // @@protoc_insertion_point(field_set:Referee_Info.ball_placement_x)
}

// optional float ball_placement_y = 8;
inline bool Referee_Info::_internal_has_ball_placement_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Referee_Info::has_ball_placement_y() const {
  return _internal_has_ball_placement_y();
}
inline void Referee_Info::clear_ball_placement_y() {
  _impl_.ball_placement_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Referee_Info::_internal_ball_placement_y() const {
  return _impl_.ball_placement_y_;
}
inline float Referee_Info::ball_placement_y() const {
  // @@protoc_insertion_point(field_get:Referee_Info.ball_placement_y)
  return _internal_ball_placement_y();
}
inline void Referee_Info::_internal_set_ball_placement_y(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ball_placement_y_ = value;
}
inline void Referee_Info::set_ball_placement_y(float value) {
  _internal_set_ball_placement_y(value);
  // @@protoc_insertion_point(field_set:Referee_Info.ball_placement_y)
}

// -------------------------------------------------------------------

// RobotIP_Infos

// required uint32 robot_id = 1;
inline bool RobotIP_Infos::_internal_has_robot_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotIP_Infos::has_robot_id() const {
  return _internal_has_robot_id();
}
inline void RobotIP_Infos::clear_robot_id() {
  _impl_.robot_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RobotIP_Infos::_internal_robot_id() const {
  return _impl_.robot_id_;
}
inline uint32_t RobotIP_Infos::robot_id() const {
  // @@protoc_insertion_point(field_get:RobotIP_Infos.robot_id)
  return _internal_robot_id();
}
inline void RobotIP_Infos::_internal_set_robot_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.robot_id_ = value;
}
inline void RobotIP_Infos::set_robot_id(uint32_t value) {
  _internal_set_robot_id(value);
  // @@protoc_insertion_point(field_set:RobotIP_Infos.robot_id)
}

// required string ip = 2;
inline bool RobotIP_Infos::_internal_has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotIP_Infos::has_ip() const {
  return _internal_has_ip();
}
inline void RobotIP_Infos::clear_ip() {
  _impl_.ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RobotIP_Infos::ip() const {
  // @@protoc_insertion_point(field_get:RobotIP_Infos.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotIP_Infos::set_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RobotIP_Infos.ip)
}
inline std::string* RobotIP_Infos::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:RobotIP_Infos.ip)
  return _s;
}
inline const std::string& RobotIP_Infos::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void RobotIP_Infos::_internal_set_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotIP_Infos::_internal_mutable_ip() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotIP_Infos::release_ip() {
  // @@protoc_insertion_point(field_release:RobotIP_Infos.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RobotIP_Infos::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RobotIP_Infos.ip)
}

// -------------------------------------------------------------------

// Other_Infos

// required int32 num_of_cameras = 1;
inline bool Other_Infos::_internal_has_num_of_cameras() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Other_Infos::has_num_of_cameras() const {
  return _internal_has_num_of_cameras();
}
inline void Other_Infos::clear_num_of_cameras() {
  _impl_.num_of_cameras_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Other_Infos::_internal_num_of_cameras() const {
  return _impl_.num_of_cameras_;
}
inline int32_t Other_Infos::num_of_cameras() const {
  // @@protoc_insertion_point(field_get:Other_Infos.num_of_cameras)
  return _internal_num_of_cameras();
}
inline void Other_Infos::_internal_set_num_of_cameras(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.num_of_cameras_ = value;
}
inline void Other_Infos::set_num_of_cameras(int32_t value) {
  _internal_set_num_of_cameras(value);
  // @@protoc_insertion_point(field_set:Other_Infos.num_of_cameras)
}

// required int32 num_of_our_robots = 2;
inline bool Other_Infos::_internal_has_num_of_our_robots() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Other_Infos::has_num_of_our_robots() const {
  return _internal_has_num_of_our_robots();
}
inline void Other_Infos::clear_num_of_our_robots() {
  _impl_.num_of_our_robots_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Other_Infos::_internal_num_of_our_robots() const {
  return _impl_.num_of_our_robots_;
}
inline int32_t Other_Infos::num_of_our_robots() const {
  // @@protoc_insertion_point(field_get:Other_Infos.num_of_our_robots)
  return _internal_num_of_our_robots();
}
inline void Other_Infos::_internal_set_num_of_our_robots(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_of_our_robots_ = value;
}
inline void Other_Infos::set_num_of_our_robots(int32_t value) {
  _internal_set_num_of_our_robots(value);
  // @@protoc_insertion_point(field_set:Other_Infos.num_of_our_robots)
}

// required int32 num_of_enemy_robots = 3;
inline bool Other_Infos::_internal_has_num_of_enemy_robots() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Other_Infos::has_num_of_enemy_robots() const {
  return _internal_has_num_of_enemy_robots();
}
inline void Other_Infos::clear_num_of_enemy_robots() {
  _impl_.num_of_enemy_robots_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Other_Infos::_internal_num_of_enemy_robots() const {
  return _impl_.num_of_enemy_robots_;
}
inline int32_t Other_Infos::num_of_enemy_robots() const {
  // @@protoc_insertion_point(field_get:Other_Infos.num_of_enemy_robots)
  return _internal_num_of_enemy_robots();
}
inline void Other_Infos::_internal_set_num_of_enemy_robots(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_of_enemy_robots_ = value;
}
inline void Other_Infos::set_num_of_enemy_robots(int32_t value) {
  _internal_set_num_of_enemy_robots(value);
  // @@protoc_insertion_point(field_set:Other_Infos.num_of_enemy_robots)
}

// required float secperframe = 4;
inline bool Other_Infos::_internal_has_secperframe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Other_Infos::has_secperframe() const {
  return _internal_has_secperframe();
}
inline void Other_Infos::clear_secperframe() {
  _impl_.secperframe_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Other_Infos::_internal_secperframe() const {
  return _impl_.secperframe_;
}
inline float Other_Infos::secperframe() const {
  // @@protoc_insertion_point(field_get:Other_Infos.secperframe)
  return _internal_secperframe();
}
inline void Other_Infos::_internal_set_secperframe(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.secperframe_ = value;
}
inline void Other_Infos::set_secperframe(float value) {
  _internal_set_secperframe(value);
  // @@protoc_insertion_point(field_set:Other_Infos.secperframe)
}

// required bool is_vision_recv = 5;
inline bool Other_Infos::_internal_has_is_vision_recv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Other_Infos::has_is_vision_recv() const {
  return _internal_has_is_vision_recv();
}
inline void Other_Infos::clear_is_vision_recv() {
  _impl_.is_vision_recv_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Other_Infos::_internal_is_vision_recv() const {
  return _impl_.is_vision_recv_;
}
inline bool Other_Infos::is_vision_recv() const {
  // @@protoc_insertion_point(field_get:Other_Infos.is_vision_recv)
  return _internal_is_vision_recv();
}
inline void Other_Infos::_internal_set_is_vision_recv(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_vision_recv_ = value;
}
inline void Other_Infos::set_is_vision_recv(bool value) {
  _internal_set_is_vision_recv(value);
  // @@protoc_insertion_point(field_set:Other_Infos.is_vision_recv)
}

// required int32 attack_direction = 6;
inline bool Other_Infos::_internal_has_attack_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Other_Infos::has_attack_direction() const {
  return _internal_has_attack_direction();
}
inline void Other_Infos::clear_attack_direction() {
  _impl_.attack_direction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Other_Infos::_internal_attack_direction() const {
  return _impl_.attack_direction_;
}
inline int32_t Other_Infos::attack_direction() const {
  // @@protoc_insertion_point(field_get:Other_Infos.attack_direction)
  return _internal_attack_direction();
}
inline void Other_Infos::_internal_set_attack_direction(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.attack_direction_ = value;
}
inline void Other_Infos::set_attack_direction(int32_t value) {
  _internal_set_attack_direction(value);
  // @@protoc_insertion_point(field_set:Other_Infos.attack_direction)
}

// required bool is_ball_moving = 7;
inline bool Other_Infos::_internal_has_is_ball_moving() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Other_Infos::has_is_ball_moving() const {
  return _internal_has_is_ball_moving();
}
inline void Other_Infos::clear_is_ball_moving() {
  _impl_.is_ball_moving_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Other_Infos::_internal_is_ball_moving() const {
  return _impl_.is_ball_moving_;
}
inline bool Other_Infos::is_ball_moving() const {
  // @@protoc_insertion_point(field_get:Other_Infos.is_ball_moving)
  return _internal_is_ball_moving();
}
inline void Other_Infos::_internal_set_is_ball_moving(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_ball_moving_ = value;
}
inline void Other_Infos::set_is_ball_moving(bool value) {
  _internal_set_is_ball_moving(value);
  // @@protoc_insertion_point(field_set:Other_Infos.is_ball_moving)
}

// -------------------------------------------------------------------

// RacoonMW_Packet

// repeated .Robot_Infos our_robots = 1;
inline int RacoonMW_Packet::_internal_our_robots_size() const {
  return _impl_.our_robots_.size();
}
inline int RacoonMW_Packet::our_robots_size() const {
  return _internal_our_robots_size();
}
inline void RacoonMW_Packet::clear_our_robots() {
  _impl_.our_robots_.Clear();
}
inline ::Robot_Infos* RacoonMW_Packet::mutable_our_robots(int index) {
  // @@protoc_insertion_point(field_mutable:RacoonMW_Packet.our_robots)
  return _impl_.our_robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >*
RacoonMW_Packet::mutable_our_robots() {
  // @@protoc_insertion_point(field_mutable_list:RacoonMW_Packet.our_robots)
  return &_impl_.our_robots_;
}
inline const ::Robot_Infos& RacoonMW_Packet::_internal_our_robots(int index) const {
  return _impl_.our_robots_.Get(index);
}
inline const ::Robot_Infos& RacoonMW_Packet::our_robots(int index) const {
  // @@protoc_insertion_point(field_get:RacoonMW_Packet.our_robots)
  return _internal_our_robots(index);
}
inline ::Robot_Infos* RacoonMW_Packet::_internal_add_our_robots() {
  return _impl_.our_robots_.Add();
}
inline ::Robot_Infos* RacoonMW_Packet::add_our_robots() {
  ::Robot_Infos* _add = _internal_add_our_robots();
  // @@protoc_insertion_point(field_add:RacoonMW_Packet.our_robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >&
RacoonMW_Packet::our_robots() const {
  // @@protoc_insertion_point(field_list:RacoonMW_Packet.our_robots)
  return _impl_.our_robots_;
}

// repeated .Robot_Infos enemy_robots = 2;
inline int RacoonMW_Packet::_internal_enemy_robots_size() const {
  return _impl_.enemy_robots_.size();
}
inline int RacoonMW_Packet::enemy_robots_size() const {
  return _internal_enemy_robots_size();
}
inline void RacoonMW_Packet::clear_enemy_robots() {
  _impl_.enemy_robots_.Clear();
}
inline ::Robot_Infos* RacoonMW_Packet::mutable_enemy_robots(int index) {
  // @@protoc_insertion_point(field_mutable:RacoonMW_Packet.enemy_robots)
  return _impl_.enemy_robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >*
RacoonMW_Packet::mutable_enemy_robots() {
  // @@protoc_insertion_point(field_mutable_list:RacoonMW_Packet.enemy_robots)
  return &_impl_.enemy_robots_;
}
inline const ::Robot_Infos& RacoonMW_Packet::_internal_enemy_robots(int index) const {
  return _impl_.enemy_robots_.Get(index);
}
inline const ::Robot_Infos& RacoonMW_Packet::enemy_robots(int index) const {
  // @@protoc_insertion_point(field_get:RacoonMW_Packet.enemy_robots)
  return _internal_enemy_robots(index);
}
inline ::Robot_Infos* RacoonMW_Packet::_internal_add_enemy_robots() {
  return _impl_.enemy_robots_.Add();
}
inline ::Robot_Infos* RacoonMW_Packet::add_enemy_robots() {
  ::Robot_Infos* _add = _internal_add_enemy_robots();
  // @@protoc_insertion_point(field_add:RacoonMW_Packet.enemy_robots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Robot_Infos >&
RacoonMW_Packet::enemy_robots() const {
  // @@protoc_insertion_point(field_list:RacoonMW_Packet.enemy_robots)
  return _impl_.enemy_robots_;
}

// required .Geometry_Info geometry = 3;
inline bool RacoonMW_Packet::_internal_has_geometry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geometry_ != nullptr);
  return value;
}
inline bool RacoonMW_Packet::has_geometry() const {
  return _internal_has_geometry();
}
inline void RacoonMW_Packet::clear_geometry() {
  if (_impl_.geometry_ != nullptr) _impl_.geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Geometry_Info& RacoonMW_Packet::_internal_geometry() const {
  const ::Geometry_Info* p = _impl_.geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::Geometry_Info&>(
      ::_Geometry_Info_default_instance_);
}
inline const ::Geometry_Info& RacoonMW_Packet::geometry() const {
  // @@protoc_insertion_point(field_get:RacoonMW_Packet.geometry)
  return _internal_geometry();
}
inline void RacoonMW_Packet::unsafe_arena_set_allocated_geometry(
    ::Geometry_Info* geometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  _impl_.geometry_ = geometry;
  if (geometry) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RacoonMW_Packet.geometry)
}
inline ::Geometry_Info* RacoonMW_Packet::release_geometry() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Geometry_Info* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Geometry_Info* RacoonMW_Packet::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:RacoonMW_Packet.geometry)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Geometry_Info* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
  return temp;
}
inline ::Geometry_Info* RacoonMW_Packet::_internal_mutable_geometry() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::Geometry_Info>(GetArenaForAllocation());
    _impl_.geometry_ = p;
  }
  return _impl_.geometry_;
}
inline ::Geometry_Info* RacoonMW_Packet::mutable_geometry() {
  ::Geometry_Info* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:RacoonMW_Packet.geometry)
  return _msg;
}
inline void RacoonMW_Packet::set_allocated_geometry(::Geometry_Info* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:RacoonMW_Packet.geometry)
}

// required .Ball_Info ball = 4;
inline bool RacoonMW_Packet::_internal_has_ball() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_ != nullptr);
  return value;
}
inline bool RacoonMW_Packet::has_ball() const {
  return _internal_has_ball();
}
inline void RacoonMW_Packet::clear_ball() {
  if (_impl_.ball_ != nullptr) _impl_.ball_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Ball_Info& RacoonMW_Packet::_internal_ball() const {
  const ::Ball_Info* p = _impl_.ball_;
  return p != nullptr ? *p : reinterpret_cast<const ::Ball_Info&>(
      ::_Ball_Info_default_instance_);
}
inline const ::Ball_Info& RacoonMW_Packet::ball() const {
  // @@protoc_insertion_point(field_get:RacoonMW_Packet.ball)
  return _internal_ball();
}
inline void RacoonMW_Packet::unsafe_arena_set_allocated_ball(
    ::Ball_Info* ball) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ball_);
  }
  _impl_.ball_ = ball;
  if (ball) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RacoonMW_Packet.ball)
}
inline ::Ball_Info* RacoonMW_Packet::release_ball() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Ball_Info* temp = _impl_.ball_;
  _impl_.ball_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Ball_Info* RacoonMW_Packet::unsafe_arena_release_ball() {
  // @@protoc_insertion_point(field_release:RacoonMW_Packet.ball)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Ball_Info* temp = _impl_.ball_;
  _impl_.ball_ = nullptr;
  return temp;
}
inline ::Ball_Info* RacoonMW_Packet::_internal_mutable_ball() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_ == nullptr) {
    auto* p = CreateMaybeMessage<::Ball_Info>(GetArenaForAllocation());
    _impl_.ball_ = p;
  }
  return _impl_.ball_;
}
inline ::Ball_Info* RacoonMW_Packet::mutable_ball() {
  ::Ball_Info* _msg = _internal_mutable_ball();
  // @@protoc_insertion_point(field_mutable:RacoonMW_Packet.ball)
  return _msg;
}
inline void RacoonMW_Packet::set_allocated_ball(::Ball_Info* ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ball_;
  }
  if (ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball);
    if (message_arena != submessage_arena) {
      ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ball_ = ball;
  // @@protoc_insertion_point(field_set_allocated:RacoonMW_Packet.ball)
}

// required .Referee_Info referee = 5;
inline bool RacoonMW_Packet::_internal_has_referee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.referee_ != nullptr);
  return value;
}
inline bool RacoonMW_Packet::has_referee() const {
  return _internal_has_referee();
}
inline void RacoonMW_Packet::clear_referee() {
  if (_impl_.referee_ != nullptr) _impl_.referee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Referee_Info& RacoonMW_Packet::_internal_referee() const {
  const ::Referee_Info* p = _impl_.referee_;
  return p != nullptr ? *p : reinterpret_cast<const ::Referee_Info&>(
      ::_Referee_Info_default_instance_);
}
inline const ::Referee_Info& RacoonMW_Packet::referee() const {
  // @@protoc_insertion_point(field_get:RacoonMW_Packet.referee)
  return _internal_referee();
}
inline void RacoonMW_Packet::unsafe_arena_set_allocated_referee(
    ::Referee_Info* referee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.referee_);
  }
  _impl_.referee_ = referee;
  if (referee) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RacoonMW_Packet.referee)
}
inline ::Referee_Info* RacoonMW_Packet::release_referee() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Referee_Info* temp = _impl_.referee_;
  _impl_.referee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Referee_Info* RacoonMW_Packet::unsafe_arena_release_referee() {
  // @@protoc_insertion_point(field_release:RacoonMW_Packet.referee)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Referee_Info* temp = _impl_.referee_;
  _impl_.referee_ = nullptr;
  return temp;
}
inline ::Referee_Info* RacoonMW_Packet::_internal_mutable_referee() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.referee_ == nullptr) {
    auto* p = CreateMaybeMessage<::Referee_Info>(GetArenaForAllocation());
    _impl_.referee_ = p;
  }
  return _impl_.referee_;
}
inline ::Referee_Info* RacoonMW_Packet::mutable_referee() {
  ::Referee_Info* _msg = _internal_mutable_referee();
  // @@protoc_insertion_point(field_mutable:RacoonMW_Packet.referee)
  return _msg;
}
inline void RacoonMW_Packet::set_allocated_referee(::Referee_Info* referee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.referee_;
  }
  if (referee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(referee);
    if (message_arena != submessage_arena) {
      referee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, referee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.referee_ = referee;
  // @@protoc_insertion_point(field_set_allocated:RacoonMW_Packet.referee)
}

// repeated .RobotIP_Infos robot_ips = 6;
inline int RacoonMW_Packet::_internal_robot_ips_size() const {
  return _impl_.robot_ips_.size();
}
inline int RacoonMW_Packet::robot_ips_size() const {
  return _internal_robot_ips_size();
}
inline void RacoonMW_Packet::clear_robot_ips() {
  _impl_.robot_ips_.Clear();
}
inline ::RobotIP_Infos* RacoonMW_Packet::mutable_robot_ips(int index) {
  // @@protoc_insertion_point(field_mutable:RacoonMW_Packet.robot_ips)
  return _impl_.robot_ips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotIP_Infos >*
RacoonMW_Packet::mutable_robot_ips() {
  // @@protoc_insertion_point(field_mutable_list:RacoonMW_Packet.robot_ips)
  return &_impl_.robot_ips_;
}
inline const ::RobotIP_Infos& RacoonMW_Packet::_internal_robot_ips(int index) const {
  return _impl_.robot_ips_.Get(index);
}
inline const ::RobotIP_Infos& RacoonMW_Packet::robot_ips(int index) const {
  // @@protoc_insertion_point(field_get:RacoonMW_Packet.robot_ips)
  return _internal_robot_ips(index);
}
inline ::RobotIP_Infos* RacoonMW_Packet::_internal_add_robot_ips() {
  return _impl_.robot_ips_.Add();
}
inline ::RobotIP_Infos* RacoonMW_Packet::add_robot_ips() {
  ::RobotIP_Infos* _add = _internal_add_robot_ips();
  // @@protoc_insertion_point(field_add:RacoonMW_Packet.robot_ips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotIP_Infos >&
RacoonMW_Packet::robot_ips() const {
  // @@protoc_insertion_point(field_list:RacoonMW_Packet.robot_ips)
  return _impl_.robot_ips_;
}

// required .Other_Infos info = 7;
inline bool RacoonMW_Packet::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool RacoonMW_Packet::has_info() const {
  return _internal_has_info();
}
inline void RacoonMW_Packet::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::Other_Infos& RacoonMW_Packet::_internal_info() const {
  const ::Other_Infos* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Other_Infos&>(
      ::_Other_Infos_default_instance_);
}
inline const ::Other_Infos& RacoonMW_Packet::info() const {
  // @@protoc_insertion_point(field_get:RacoonMW_Packet.info)
  return _internal_info();
}
inline void RacoonMW_Packet::unsafe_arena_set_allocated_info(
    ::Other_Infos* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RacoonMW_Packet.info)
}
inline ::Other_Infos* RacoonMW_Packet::release_info() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Other_Infos* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Other_Infos* RacoonMW_Packet::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:RacoonMW_Packet.info)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Other_Infos* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Other_Infos* RacoonMW_Packet::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Other_Infos>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Other_Infos* RacoonMW_Packet::mutable_info() {
  ::Other_Infos* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:RacoonMW_Packet.info)
  return _msg;
}
inline void RacoonMW_Packet::set_allocated_info(::Other_Infos* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:RacoonMW_Packet.info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Referee_Info_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Referee_Info_Command>() {
  return ::Referee_Info_Command_descriptor();
}
template <> struct is_proto_enum< ::Referee_Info_Stage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Referee_Info_Stage>() {
  return ::Referee_Info_Stage_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_to_5fracoonai_2eproto
